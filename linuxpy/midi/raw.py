#
# This file is part of the linuxpy project
#
# Copyright (c) 2023 Tiago Coutinho
# Distributed under the GPLv3 license. See LICENSE for more info.

# This file has been generated by __main__
# Date: 2023-11-07 06:37:12.044793
# System: Linux
# Release: 6.2.0-36-generic
# Version: #37~22.04.1-Ubuntu SMP PREEMPT_DYNAMIC Mon Oct  9 15:34:04 UTC 2

import enum

from linuxpy.ctypes import POINTER, Struct, Union, cchar, cint, cuint, cvoidp, u8, u16
from linuxpy.ioctl import IOR as _IOR, IOW as _IOW, IOWR as _IOWR


class EventLength(enum.IntEnum):
    FIXED = 0 << 2  # fixed event size
    VARIABLE = 1 << 2  # variable event size
    VARUSR = 2 << 2  # variable event size - user memory space
    MASK = 3 << 2


class TimeStamp(enum.IntFlag):
    TICK = 0 << 0  # timestamp in clock ticks
    REAL = 1 << 0  # timestamp in real time
    MASK = 1 << 0


class TimeMode(enum.IntFlag):
    ABS = 0 << 1  # absolute timestamp
    REL = 1 << 1  # relative to current time
    MASK = 1 << 1


class Priority(enum.IntFlag):
    NORMAL = 0 << 4  # normal priority
    HIGH = 1 << 4  # event should be processed before others
    MASK = 1 << 4


class EventType(enum.IntEnum):
    SYSTEM = 0x0
    RESULT = 0x1
    NOTE = 0x5
    NOTEON = 0x6
    NOTEOFF = 0x7
    KEYPRESS = 0x8
    CONTROLLER = 0xA
    PGMCHANGE = 0xB
    CHANPRESS = 0xC
    PITCHBEND = 13  # *< from -8192 to 8191
    CONTROL14 = 14  # *< 14 bit controller value
    NONREGPARAM = 15  # *< 14 bit NRPN address + 14 bit unsigned value
    REGPARAM = 16  # *< 14 bit RPN address + 14 bit unsigned value
    SONGPOS = 20  # Song Position Pointer with LSB and MSB values
    SONGSEL = 21  # Song Select with song ID number
    QFRAME = 22  # midi time code quarter frame
    TIMESIGN = 23  # SMF Time Signature event
    KEYSIGN = 24  # SMF Key Signature event
    START = 30  # midi Real Time Start message
    CONTINUE = 31  # midi Real Time Continue message
    STOP = 32  # midi Real Time Stop message
    SETPOS_TICK = 33  # set tick queue position
    SETPOS_TIME = 34  # set realtime queue position
    TEMPO = 35  # (SMF) Tempo event
    CLOCK = 36  # midi Real Time Clock message
    TICK = 37  # midi Real Time Tick message
    QUEUE_SKEW = 38  # skew queue tempo
    TUNE_REQUEST = 40  # tune request
    RESET = 41  # reset to power-on state
    SENSING = 42  # "active sensing" event
    ECHO = 50  # echo event
    OSS = 51  # OSS raw event
    CLIENT_START = 60  # new client has connected
    CLIENT_EXIT = 61  # client has left the system
    CLIENT_CHANGE = 62  # client status/info has changed
    PORT_START = 63  # new port was created
    PORT_EXIT = 64  # port was deleted from system
    PORT_CHANGE = 65  # port status/info has changed
    PORT_SUBSCRIBED = 66  # ports connected
    PORT_UNSUBSCRIBED = 67  # ports disconnected
    USR0 = 0x5A
    USR1 = 0x5B
    USR2 = 0x5C
    USR3 = 0x5D
    USR4 = 0x5E
    USR5 = 0x5F
    USR6 = 0x60
    USR7 = 0x61
    USR8 = 0x62
    USR9 = 0x63
    SYSEX = 130  # system exclusive data (variable length)
    BOUNCE = 131  # error event
    USR_VAR0 = 0x87
    USR_VAR1 = 0x88
    USR_VAR2 = 0x89
    USR_VAR3 = 0x8A
    USR_VAR4 = 0x8B
    KERNEL_ERROR = 0x96
    KERNEL_QUOTE = 151  # obsolete
    NONE = 0xFF


class ClientType(enum.IntEnum):
    SYSTEM = 0x0
    DUMMY = 14  # midi through
    OSS = 15  # oss sequencer emulator


class Filter(enum.IntFlag):
    BROADCAST = 1 << 0  # accept broadcast messages
    MULTICAST = 1 << 1  # accept multicast messages
    BOUNCE = 1 << 2  # accept bounce event in error
    USE_EVENT = 1 << 31  # use event filter


class Remove(enum.IntFlag):
    INPUT = 1 << 0  # Flush input queues
    OUTPUT = 1 << 1  # Flush output queues
    DEST = 1 << 2  # Restrict by destination q:client:port
    DEST_CHANNEL = 1 << 3  # Restrict by channel
    TIME_BEFORE = 1 << 4  # Restrict to before time
    TIME_AFTER = 1 << 5  # Restrict to time or after
    TIME_TICK = 1 << 6  # Time is in ticks
    EVENT_TYPE = 1 << 7  # Restrict to event type
    IGNORE_OFF = 1 << 8  # Do not flush off events
    TAG_MATCH = 1 << 9  # Restrict to events with given tag


class PortSystem(enum.IntFlag):
    TIMER = 0x0
    ANNOUNCE = 0x1


class PortCapability(enum.IntFlag):
    READ = 1 << 0  # readable from this port
    WRITE = 1 << 1  # writable to this port
    SYNC_READ = 1 << 2
    SYNC_WRITE = 1 << 3
    DUPLEX = 1 << 4
    SUBS_READ = 1 << 5  # allow read subscription
    SUBS_WRITE = 1 << 6  # allow write subscription
    NO_EXPORT = 1 << 7  # routing not allowed


class PortType(enum.IntFlag):
    SPECIFIC = 1 << 0  # hardware specific
    MIDI_GENERIC = 1 << 1  # generic MIDI device
    MIDI_GM = 1 << 2  # General MIDI compatible device
    MIDI_GS = 1 << 3  # GS compatible device
    MIDI_XG = 1 << 4  # XG compatible device
    MIDI_MT32 = 1 << 5  # MT-32 compatible device
    MIDI_GM2 = 1 << 6  # General MIDI 2 compatible device
    SYNTH = 1 << 10  # Synth device (no MIDI compatible - direct wavetable)
    DIRECT_SAMPLE = 1 << 11  # Sampling device (support sample download)
    SAMPLE = 1 << 12  # Sampling device (sample can be downloaded at any time)
    HARDWARE = 1 << 16  # driver for a hardware device
    SOFTWARE = 1 << 17  # implemented in software
    SYNTHESIZER = 1 << 18  # generates sound
    PORT = 1 << 19  # connects to other device(s)
    APPLICATION = 1 << 20  # application (sequencer/editor)


class PortFlag(enum.IntFlag):
    GIVEN_PORT = 1 << 0
    TIMESTAMP = 1 << 1
    TIME_REAL = 1 << 2


class QueueFlga(enum.IntFlag):
    SYNC = 1 << 0  # sync enabled


class Timer(enum.IntEnum):
    ALSA = 0  # ALSA timer
    MIDI_CLOCK = 1  # Midi Clock (CLOCK event)
    MIDI_TICK = 2  # Midi Timer Tick (TICK event)


class QuerySubscription(enum.IntEnum):
    READ = 0x0
    WRITE = 0x1


snd_seq_tick_time_t = cuint


class snd_seq_real_time(Struct):
    _fields_ = [
        ("tv_sec", cuint),
        ("tv_nsec", cuint),
    ]


# It's a Union so not automatically generated
class snd_seq_timestamp(Union):
    _fields_ = [
        ("tick", snd_seq_tick_time_t),
        ("time", snd_seq_real_time),
    ]


# Defined in /usr/include/sound/asound.h
class snd_timer_id(Struct):
    _fields_ = [
        ("dev_class", cint),
        ("dev_sclass", cint),
        ("card", cint),
        ("device", cint),
        ("subdevice", cint),
    ]


class snd_seq_addr(Struct):
    _pack_ = True


snd_seq_addr._fields_ = [("client", u8), ("port", u8)]


class snd_seq_connect(Struct):
    _pack_ = True


snd_seq_connect._fields_ = [("sender", snd_seq_addr), ("dest", snd_seq_addr)]


class snd_seq_ev_note(Struct):
    pass


snd_seq_ev_note._fields_ = [
    ("channel", u8),
    ("note", u8),
    ("velocity", u8),
    ("off_velocity", u8),
    ("duration", cuint),
]


class snd_seq_ev_ctrl(Struct):
    pass


snd_seq_ev_ctrl._fields_ = [
    ("channel", u8),
    ("unused1", u8),
    ("unused2", u8),
    ("unused3", u8),
    ("param", cuint),
    ("value", cint),
]


class snd_seq_ev_raw8(Struct):
    _pack_ = True


snd_seq_ev_raw8._fields_ = [("d", cchar * 12)]


class snd_seq_ev_raw32(Struct):
    pass


snd_seq_ev_raw32._fields_ = [("d", cuint * 3)]


class snd_seq_ev_ext(Struct):
    _pack_ = True


snd_seq_ev_ext._fields_ = [("len", cuint), ("ptr", cvoidp)]


class snd_seq_result(Struct):
    pass


snd_seq_result._fields_ = [("event", cint), ("result", cint)]


class snd_seq_real_time(Struct):
    pass


snd_seq_real_time._fields_ = [("tv_sec", cuint), ("tv_nsec", cuint)]


class snd_seq_queue_skew(Struct):
    pass


snd_seq_queue_skew._fields_ = [("value", cuint), ("base", cuint)]


class snd_seq_ev_queue_control(Struct):
    class M1(Union):
        pass

    M1._fields_ = [
        ("value", cint),
        ("time", snd_seq_timestamp),
        ("position", cuint),
        ("skew", snd_seq_queue_skew),
        ("d32", cuint * 2),
        ("d8", cchar * 8),
    ]


snd_seq_ev_queue_control._fields_ = [
    ("queue", u8),
    ("pad", cchar * 3),
    ("param", snd_seq_ev_queue_control.M1),
]


class snd_seq_ev_quote(Struct):
    _pack_ = True


class snd_seq_event(Struct):
    class M1(Union):
        pass


snd_seq_ev_quote._fields_ = [
    ("origin", snd_seq_addr),
    ("value", u16),
    ("event", POINTER(snd_seq_event)),
]


snd_seq_event.M1._fields_ = [
    ("note", snd_seq_ev_note),
    ("control", snd_seq_ev_ctrl),
    ("raw8", snd_seq_ev_raw8),
    ("raw32", snd_seq_ev_raw32),
    ("ext", snd_seq_ev_ext),
    ("queue", snd_seq_ev_queue_control),
    ("time", snd_seq_timestamp),
    ("addr", snd_seq_addr),
    ("connect", snd_seq_connect),
    ("result", snd_seq_result),
    ("quote", snd_seq_ev_quote),
]


snd_seq_event._fields_ = [
    ("type", u8),
    ("flags", u8),
    ("tag", cchar),
    ("queue", u8),
    ("time", snd_seq_timestamp),
    ("source", snd_seq_addr),
    ("dest", snd_seq_addr),
    ("data", snd_seq_event.M1),
]


class snd_seq_event_bounce(Struct):
    pass


snd_seq_event_bounce._fields_ = [("err", cint), ("event", snd_seq_event)]


class snd_seq_system_info(Struct):
    pass


snd_seq_system_info._fields_ = [
    ("queues", cint),
    ("clients", cint),
    ("ports", cint),
    ("channels", cint),
    ("cur_clients", cint),
    ("cur_queues", cint),
    ("reserved", cchar * 24),
]


class snd_seq_running_info(Struct):
    _pack_ = True


snd_seq_running_info._fields_ = [
    ("client", u8),
    ("big_endian", u8),
    ("cpu_mode", u8),
    ("pad", u8),
    ("reserved", cchar * 12),
]


class snd_seq_client_info(Struct):
    pass


snd_seq_client_info._fields_ = [
    ("client", cint),
    ("type", cint),
    ("name", cchar * 64),
    ("filter", cuint),
    ("multicast_filter", cchar * 8),
    ("event_filter", cchar * 32),
    ("num_ports", cint),
    ("event_lost", cint),
    ("card", cint),
    ("pid", cint),
    ("reserved", cchar * 56),
]


class snd_seq_client_pool(Struct):
    pass


snd_seq_client_pool._fields_ = [
    ("client", cint),
    ("output_pool", cint),
    ("input_pool", cint),
    ("output_room", cint),
    ("output_free", cint),
    ("input_free", cint),
    ("reserved", cchar * 64),
]


class snd_seq_remove_events(Struct):
    pass


snd_seq_remove_events._fields_ = [
    ("remove_mode", cuint),
    ("time", snd_seq_timestamp),
    ("queue", u8),
    ("dest", snd_seq_addr),
    ("channel", u8),
    ("type", cint),
    ("tag", cchar),
    ("reserved", cint * 10),
]


class snd_seq_port_info(Struct):
    pass


snd_seq_port_info._fields_ = [
    ("addr", snd_seq_addr),
    ("name", cchar * 64),
    ("capability", cuint),
    ("type", cuint),
    ("midi_channels", cint),
    ("midi_voices", cint),
    ("synth_voices", cint),
    ("read_use", cint),
    ("write_use", cint),
    ("kernel", POINTER(None)),
    ("flags", cuint),
    ("time_queue", u8),
    ("reserved", cchar * 59),
]


class snd_seq_queue_info(Struct):
    pass


snd_seq_queue_info._fields_ = [
    ("queue", cint),
    ("owner", cint),
    ("locked", cuint),
    ("name", cchar * 64),
    ("flags", cuint),
    ("reserved", cchar * 60),
]


class snd_seq_queue_status(Struct):
    pass


snd_seq_queue_status._fields_ = [
    ("queue", cint),
    ("events", cint),
    ("tick", cuint),
    ("time", snd_seq_real_time),
    ("running", cint),
    ("flags", cint),
    ("reserved", cchar * 64),
]


class snd_seq_queue_tempo(Struct):
    pass


snd_seq_queue_tempo._fields_ = [
    ("queue", cint),
    ("tempo", cuint),
    ("ppq", cint),
    ("skew_value", cuint),
    ("skew_base", cuint),
    ("reserved", cchar * 24),
]


class snd_seq_queue_timer(Struct):
    class M1(Union):
        class M1(Struct):
            pass

        M1._fields_ = [("id", snd_timer_id), ("resolution", cuint)]

    M1._fields_ = [("alsa", M1.M1)]


snd_seq_queue_timer._fields_ = [
    ("queue", cint),
    ("type", cint),
    ("u", snd_seq_queue_timer.M1),
    ("reserved", cchar * 64),
]


class snd_seq_queue_client(Struct):
    pass


snd_seq_queue_client._fields_ = [
    ("queue", cint),
    ("client", cint),
    ("used", cint),
    ("reserved", cchar * 64),
]


class snd_seq_port_subscribe(Struct):
    pass


snd_seq_port_subscribe._fields_ = [
    ("sender", snd_seq_addr),
    ("dest", snd_seq_addr),
    ("voices", cuint),
    ("flags", cuint),
    ("queue", u8),
    ("pad", cchar * 3),
    ("reserved", cchar * 64),
]


class snd_seq_query_subs(Struct):
    pass


snd_seq_query_subs._fields_ = [
    ("root", snd_seq_addr),
    ("type", cint),
    ("index", cint),
    ("num_subs", cint),
    ("addr", snd_seq_addr),
    ("queue", u8),
    ("flags", cuint),
    ("reserved", cchar * 64),
]


class snd_seq_timestamp(Union):
    pass


snd_seq_timestamp._fields_ = [("tick", cuint), ("time", snd_seq_real_time)]


class IOC(enum.IntEnum):
    PVERSION = _IOR("S", 0x00, cint)
    CLIENT_ID = _IOR("S", 0x01, cint)
    SYSTEM_INFO = _IOWR("S", 0x02, snd_seq_system_info)
    RUNNING_MODE = _IOWR("S", 0x03, snd_seq_running_info)
    GET_CLIENT_INFO = _IOWR("S", 0x10, snd_seq_client_info)
    SET_CLIENT_INFO = _IOW("S", 0x11, snd_seq_client_info)
    CREATE_PORT = _IOWR("S", 0x20, snd_seq_port_info)
    DELETE_PORT = _IOW("S", 0x21, snd_seq_port_info)
    GET_PORT_INFO = _IOWR("S", 0x22, snd_seq_port_info)
    SET_PORT_INFO = _IOW("S", 0x23, snd_seq_port_info)
    SUBSCRIBE_PORT = _IOW("S", 0x30, snd_seq_port_subscribe)
    UNSUBSCRIBE_PORT = _IOW("S", 0x31, snd_seq_port_subscribe)
    CREATE_QUEUE = _IOWR("S", 0x32, snd_seq_queue_info)
    DELETE_QUEUE = _IOW("S", 0x33, snd_seq_queue_info)
    GET_QUEUE_INFO = _IOWR("S", 0x34, snd_seq_queue_info)
    SET_QUEUE_INFO = _IOWR("S", 0x35, snd_seq_queue_info)
    GET_NAMED_QUEUE = _IOWR("S", 0x36, snd_seq_queue_info)
    GET_QUEUE_STATUS = _IOWR("S", 0x40, snd_seq_queue_status)
    GET_QUEUE_TEMPO = _IOWR("S", 0x41, snd_seq_queue_tempo)
    SET_QUEUE_TEMPO = _IOW("S", 0x42, snd_seq_queue_tempo)
    GET_QUEUE_TIMER = _IOWR("S", 0x45, snd_seq_queue_timer)
    SET_QUEUE_TIMER = _IOW("S", 0x46, snd_seq_queue_timer)
    GET_QUEUE_CLIENT = _IOWR("S", 0x49, snd_seq_queue_client)
    SET_QUEUE_CLIENT = _IOW("S", 0x4A, snd_seq_queue_client)
    GET_CLIENT_POOL = _IOWR("S", 0x4B, snd_seq_client_pool)
    SET_CLIENT_POOL = _IOW("S", 0x4C, snd_seq_client_pool)
    REMOVE_EVENTS = _IOW("S", 0x4E, snd_seq_remove_events)
    QUERY_SUBS = _IOWR("S", 0x4F, snd_seq_query_subs)
    GET_SUBSCRIPTION = _IOWR("S", 0x50, snd_seq_port_subscribe)
    QUERY_NEXT_CLIENT = _IOWR("S", 0x51, snd_seq_client_info)
    QUERY_NEXT_PORT = _IOWR("S", 0x52, snd_seq_port_info)

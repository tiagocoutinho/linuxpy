#
# This file is part of the linuxpy project
#
# Copyright (c) 2025 Tiago Coutinho
# Distributed under the GPLv3 license. See LICENSE for more info.

# This file has been generated by __main__
# Date: 2025-05-23 17:36:24.818710
# System: Linux
# Release: 6.8.0-60-generic
# Version: #63-Ubuntu SMP PREEMPT_DYNAMIC Tue Apr 15 19:04:15 UTC 2025

import enum

from linuxpy.ctypes import POINTER, Struct, Union, cchar, cint, cuint, culong, i16, u8, u16
from linuxpy.sock import sockaddr


class EventType(enum.IntEnum):
    TXDROP = 0x8C00  # Packet dropped to excessive retry
    QUAL = 0x8C01  # Quality part of statistics (scan)
    CUSTOM = 0x8C02  # Driver specific ascii string
    REGISTERED = 0x8C03  # Discovered a new node (AP mode)
    EXPIRED = 0x8C04  # Expired a node (AP mode)
    GENIE = 0x8C05  # Generic IE (WPA, RSN, WMM, ..)
    MICHAELMICFAILURE = 0x8C06  # Michael MIC failure
    ASSOCREQIE = 0x8C07  # IEs used in (Re)Association Request.
    ASSOCRESPIE = 0x8C08  # IEs used in (Re)Association
    PMKIDCAND = 0x8C09  # PMKID candidate for RSN
    FIRST = 0x8C00


class OperationMode(enum.IntEnum):
    AUTO = 0  # Let the driver decides
    ADHOC = 1  # Single cell network
    INFRA = 2  # Multi cell network, roaming, ...
    MASTER = 3  # Synchronisation master or Access Point
    REPEAT = 4  # Wireless Repeater (forwarder)
    SECOND = 5  # Secondary master/repeater (backup)
    MONITOR = 6  # Passive monitor (listen only)
    MESH = 7  # Mesh (IEEE 802.11s) network


class Auth(enum.IntEnum):
    INDEX = 0xFFF
    FLAGS = 0xF000
    WPA_VERSION = 0x0
    CIPHER_PAIRWISE = 0x1
    CIPHER_GROUP = 0x2
    KEY_MGMT = 0x3
    TKIP_COUNTERMEASURES = 0x4
    DROP_UNENCRYPTED = 0x5
    _80211_AUTH_ALG = 0x6
    WPA_ENABLED = 0x7
    RX_UNENCRYPTED_EAPOL = 0x8
    ROAMING_CONTROL = 0x9
    PRIVACY_INVOKED = 0xA
    CIPHER_GROUP_MGMT = 0xB
    MFP = 0xC
    WPA_VERSION_DISABLED = 0x1
    WPA_VERSION_WPA = 0x2
    WPA_VERSION_WPA2 = 0x4
    CIPHER_NONE = 0x1
    CIPHER_WEP40 = 0x2
    CIPHER_TKIP = 0x4
    CIPHER_CCMP = 0x8
    CIPHER_WEP104 = 0x10
    CIPHER_AES_CMAC = 0x20
    KEY_MGMT_802_1X = 0x1
    KEY_MGMT_PSK = 0x2
    ALG_OPEN_SYSTEM = 0x1
    ALG_SHARED_KEY = 0x2
    ALG_LEAP = 0x4
    ROAMING_ENABLE = 0  # driver/firmware based roaming
    ROAMING_DISABLE = 1  # user space program used for roaming
    MFP_DISABLED = 0  # MFP disabled
    MFP_OPTIONAL = 1  # MFP optional
    MFP_REQUIRED = 2  # MFP required


class EncodeAlg(enum.IntEnum):
    NONE = 0x0
    WEP = 0x1
    TKIP = 0x2
    CCMP = 0x3
    PMK = 0x4
    AES_CMAC = 0x5


class EncodeExt(enum.IntFlag):
    TX_SEQ_VALID = 0x1
    RX_SEQ_VALID = 0x2
    GROUP_KEY = 0x4
    SET_TX_KEY = 0x8


class EncodingFlag(enum.IntFlag):
    INDEX = 0x00FF  # Token index (if needed)
    FLAGS = 0xFF00  # Flags defined below
    MODE = 0xF000  # Modes defined below
    DISABLED = 0x8000  # Encoding disabled
    ENABLED = 0x0000  # Encoding enabled
    RESTRICTED = 0x4000  # Refuse non-encoded packets
    OPEN = 0x2000  # Accept non-encoded packets
    NOKEY = 0x0800  # Key is write only, so not present
    TEMP = 0x0400  # Temporary key
    SEQ_MAX_SIZE = 0x8


class StatsFlag(enum.IntFlag):
    QUAL_UPDATED = 0x01  # Value was updated since last read
    LEVEL_UPDATED = 0x2
    NOISE_UPDATED = 0x4
    ALL_UPDATED = 0x7
    DBM = 0x08  # Level + Noise are dBm
    QUAL_INVALID = 0x10  # Driver doesn't provide value
    LEVEL_INVALID = 0x20
    NOISE_INVALID = 0x40
    RCPI = 0x80  # Level + Noise are 802.11k RCPI
    ALL_INVALID = 0x70


class FrequencyFlag(enum.IntFlag):
    AUTO = 0x00  # Let the driver decides
    FIXED = 0x01  # Force a specific value


class PowerFlag(enum.IntFlag):
    ON = 0x0000  # No details...
    TYPE = 0xF000  # Type of parameter
    PERIOD = 0x1000  # Value is a period/duration of
    TIMEOUT = 0x2000  # Value is a timeout (to go asleep)
    MODE = 0x0F00  # Power Management mode
    UNICAST_R = 0x0100  # Receive only unicast messages
    MULTICAST_R = 0x0200  # Receive only multicast messages
    ALL_R = 0x0300  # Receive all messages though PM
    FORCE_S = 0x0400  # Force PM procedure for sending unicast
    REPEATER = 0x0800  # Repeat broadcast messages in PM period
    MODIFIER = 0x000F  # Modify a parameter
    MIN = 0x0001  # Value is a minimum
    MAX = 0x0002  # Value is a maximum
    RELATIVE = 0x0004  # Value is not in seconds/ms/us


class TransmitPowerFlag(enum.IntFlag):
    TYPE = 0x00FF  # Type of value
    DBM = 0x0000  # Value is in dBm
    MWATT = 0x0001  # Value is in mW
    RELATIVE = 0x0002  # Value is in arbitrary units
    RANGE = 0x1000  # Range of value between min/max


class RetryFlag(enum.IntFlag):
    ON = 0x0000  # No details...
    TYPE = 0xF000  # Type of parameter
    LIMIT = 0x1000  # Maximum number of retries
    LIFETIME = 0x2000  # Maximum duration of retries in us
    MODIFIER = 0x00FF  # Modify a parameter
    MIN = 0x0001  # Value is a minimum
    MAX = 0x0002  # Value is a maximum
    RELATIVE = 0x0004  # Value is not in seconds/ms/us
    SHORT = 0x0010  # Value is for short packets
    LONG = 0x0020  # Value is for long packets


class ScanCapabilityFlag(enum.IntFlag):
    NONE = 0x0
    ESSID = 0x1
    BSSID = 0x2
    CHANNEL = 0x4
    MODE = 0x8
    RATE = 0x10
    TYPE = 0x20
    TIME = 0x40


class ScanType(enum.IntEnum):
    ACTIVE = 0x0
    PASSIVE = 0x1


class ScanFlag(enum.IntFlag):
    DEFAULT = 0x0000  # Default scan of the driver
    ALL_ESSID = 0x0001  # Scan all ESSIDs
    THIS_ESSID = 0x0002  # Scan only this ESSID
    ALL_FREQ = 0x0004  # Scan all Frequencies
    THIS_FREQ = 0x0008  # Scan only this Frequency
    ALL_MODE = 0x0010  # Scan all Modes
    THIS_MODE = 0x0020  # Scan only this Mode
    ALL_RATE = 0x0040  # Scan all Bit-Rates
    THIS_RATE = 0x0080  # Scan only this Bit-Rate
    MAX_DATA = 4096  # In bytes


class MicFailureFlag(enum.IntFlag):
    KEY_ID = 0x00000003  # Key ID 0..3
    GROUP = 0x4
    PAIRWISE = 0x8
    STAKEY = 0x10
    COUNT = 0x00000060  # 1 or 2 (0 = count not supported)


class EncodeCapabilityFlag(enum.IntFlag):
    WPA = 0x1
    WPA2 = 0x2
    CIPHER_TKIP = 0x4
    CIPHER_CCMP = 0x8
    _4WAY_HANDSHAKE = 0x10


class NetDeviceFlags(enum.IntFlag):
    UP = 1
    BROADCAST = 2
    DEBUG = 4
    LOOPBACK = 8
    POINTOPOINT = 16
    NOTRAILERS = 32
    RUNNING = 64
    NOARP = 128
    PROMISC = 256
    ALLMULTI = 512
    MASTER = 1024
    SLAVE = 2048
    MULTICAST = 4096
    PORTSEL = 8192
    AUTOMEDIA = 16384
    DYNAMIC = 32768
    LOWER_UP = 65536
    DORMANT = 131072
    ECHO = 262144


class NlmsgerrAttrs(enum.IntEnum):
    NLMSGERR_ATTR_UNUSED = 0
    NLMSGERR_ATTR_MSG = 1
    NLMSGERR_ATTR_OFFS = 2
    NLMSGERR_ATTR_COOKIE = 3
    NLMSGERR_ATTR_POLICY = 4
    NLMSGERR_ATTR_MISS_TYPE = 5
    NLMSGERR_ATTR_MISS_NEST = 6
    __NLMSGERR_ATTR_MAX = 7
    NLMSGERR_ATTR_MAX = 6


class NlMmapStatus(enum.IntEnum):
    UNUSED = 0
    RESERVED = 1
    VALID = 2
    COPY = 3
    SKIP = 4


class NetlinkAttributeType(enum.IntEnum):
    INVALID = 0
    FLAG = 1
    U8 = 2
    U16 = 3
    U32 = 4
    U64 = 5
    S8 = 6
    S16 = 7
    S32 = 8
    S64 = 9
    BINARY = 10
    STRING = 11
    NUL_STRING = 12
    NESTED = 13
    NESTED_ARRAY = 14
    BITFIELD32 = 15
    SINT = 16
    UINT = 17


class NetlinkPolicyTypeAttr(enum.IntEnum):
    NL_POLICY_TYPE_ATTR_UNSPEC = 0
    NL_POLICY_TYPE_ATTR_TYPE = 1
    NL_POLICY_TYPE_ATTR_MIN_VALUE_S = 2
    NL_POLICY_TYPE_ATTR_MAX_VALUE_S = 3
    NL_POLICY_TYPE_ATTR_MIN_VALUE_U = 4
    NL_POLICY_TYPE_ATTR_MAX_VALUE_U = 5
    NL_POLICY_TYPE_ATTR_MIN_LENGTH = 6
    NL_POLICY_TYPE_ATTR_MAX_LENGTH = 7
    NL_POLICY_TYPE_ATTR_POLICY_IDX = 8
    NL_POLICY_TYPE_ATTR_POLICY_MAXTYPE = 9
    NL_POLICY_TYPE_ATTR_BITFIELD32_MASK = 10
    NL_POLICY_TYPE_ATTR_PAD = 11
    NL_POLICY_TYPE_ATTR_MASK = 12
    __NL_POLICY_TYPE_ATTR_MAX = 13
    NL_POLICY_TYPE_ATTR_MAX = 12


class sync_serial_settings(Struct):
    pass


sync_serial_settings._fields_ = [("clock_rate", cuint), ("clock_type", cuint), ("loopback", u16)]


class te1_settings(Struct):
    pass


te1_settings._fields_ = [("clock_rate", cuint), ("clock_type", cuint), ("loopback", u16), ("slot_map", cuint)]


class raw_hdlc_proto(Struct):
    pass


raw_hdlc_proto._fields_ = [("encoding", u16), ("parity", u16)]


class fr_proto(Struct):
    pass


fr_proto._fields_ = [
    ("t391", cuint),
    ("t392", cuint),
    ("n391", cuint),
    ("n392", cuint),
    ("n393", cuint),
    ("lmi", u16),
    ("dce", u16),
]


class fr_proto_pvc(Struct):
    pass


fr_proto_pvc._fields_ = [("dlci", cuint)]


class fr_proto_pvc_info(Struct):
    pass


fr_proto_pvc_info._fields_ = [("dlci", cuint), ("master", cchar * 16)]


class cisco_proto(Struct):
    pass


cisco_proto._fields_ = [("interval", cuint), ("timeout", cuint)]


class x25_hdlc_proto(Struct):
    pass


x25_hdlc_proto._fields_ = [
    ("dce", u16),
    ("modulo", cuint),
    ("window", cuint),
    ("t1", cuint),
    ("t2", cuint),
    ("n2", cuint),
]


class ifmap(Struct):
    pass


ifmap._fields_ = [
    ("mem_start", culong),
    ("mem_end", culong),
    ("base_addr", u16),
    ("irq", u8),
    ("dma", u8),
    ("port", u8),
]


class if_settings(Struct):
    class M1(Union):
        pass

    M1._fields_ = [
        ("raw_hdlc", POINTER(raw_hdlc_proto)),
        ("cisco", POINTER(cisco_proto)),
        ("fr", POINTER(fr_proto)),
        ("fr_pvc", POINTER(fr_proto_pvc)),
        ("fr_pvc_info", POINTER(fr_proto_pvc_info)),
        ("x25", POINTER(x25_hdlc_proto)),
        ("sync", POINTER(sync_serial_settings)),
        ("te1", POINTER(te1_settings)),
    ]


if_settings._fields_ = [("type", cuint), ("size", cuint), ("ifs_ifsu", if_settings.M1)]


class ifreq(Struct):
    class M1(Union):
        _pack_ = True

    M1._fields_ = [("ifrn_name", cchar * 16)]

    class M2(Union):
        pass

    M2._fields_ = [
        ("ifru_addr", sockaddr),
        ("ifru_dstaddr", sockaddr),
        ("ifru_broadaddr", sockaddr),
        ("ifru_netmask", sockaddr),
        ("ifru_hwaddr", sockaddr),
        ("ifru_flags", i16),
        ("ifru_ivalue", cint),
        ("ifru_mtu", cint),
        ("ifru_map", ifmap),
        ("ifru_slave", cchar * 16),
        ("ifru_newname", cchar * 16),
        ("ifru_data", POINTER(None)),
        ("ifru_settings", if_settings),
    ]


ifreq._fields_ = [("ifr_ifrn", ifreq.M1), ("ifr_ifru", ifreq.M2)]


class ifconf(Struct):
    class M1(Union):
        pass

    M1._fields_ = [("ifcu_buf", POINTER(cchar)), ("ifcu_req", POINTER(ifreq))]


ifconf._fields_ = [("ifc_len", cint), ("ifc_ifcu", ifconf.M1)]


class sockaddr_nl(Struct):
    pass


sockaddr_nl._fields_ = [("nl_family", u16), ("nl_pad", u16), ("nl_pid", cuint), ("nl_groups", cuint)]


class nlmsghdr(Struct):
    pass


nlmsghdr._fields_ = [
    ("nlmsg_len", cuint),
    ("nlmsg_type", u16),
    ("nlmsg_flags", u16),
    ("nlmsg_seq", cuint),
    ("nlmsg_pid", cuint),
]


class nlmsgerr(Struct):
    pass


nlmsgerr._fields_ = [("error", cint), ("msg", nlmsghdr)]


class nl_pktinfo(Struct):
    pass


nl_pktinfo._fields_ = [("group", cuint)]


class nl_mmap_req(Struct):
    pass


nl_mmap_req._fields_ = [
    ("nm_block_size", cuint),
    ("nm_block_nr", cuint),
    ("nm_frame_size", cuint),
    ("nm_frame_nr", cuint),
]


class nl_mmap_hdr(Struct):
    pass


nl_mmap_hdr._fields_ = [
    ("nm_status", cuint),
    ("nm_len", cuint),
    ("nm_group", cuint),
    ("nm_pid", cuint),
    ("nm_uid", cuint),
    ("nm_gid", cuint),
]


class nlattr(Struct):
    pass


nlattr._fields_ = [("nla_len", u16), ("nla_type", u16)]


class nla_bitfield32(Struct):
    pass


nla_bitfield32._fields_ = [("value", cuint), ("selector", cuint)]


class iw_param(Struct):
    pass


iw_param._fields_ = [("value", cint), ("fixed", u8), ("disabled", u8), ("flags", u16)]


class iw_point(Struct):
    pass


iw_point._fields_ = [("pointer", POINTER(None)), ("length", u16), ("flags", u16)]


class iw_freq(Struct):
    pass


iw_freq._fields_ = [("m", cint), ("e", i16), ("i", u8), ("flags", u8)]


class iw_quality(Struct):
    _pack_ = True


iw_quality._fields_ = [("qual", u8), ("level", u8), ("noise", u8), ("updated", u8)]


class iw_discarded(Struct):
    pass


iw_discarded._fields_ = [("nwid", cuint), ("code", cuint), ("fragment", cuint), ("retries", cuint), ("misc", cuint)]


class iw_missed(Struct):
    pass


iw_missed._fields_ = [("beacon", cuint)]


class iw_thrspy(Struct):
    pass


iw_thrspy._fields_ = [("addr", sockaddr), ("qual", iw_quality), ("low", iw_quality), ("high", iw_quality)]


class iw_scan_req(Struct):
    pass


iw_scan_req._fields_ = [
    ("scan_type", u8),
    ("essid_len", u8),
    ("num_channels", u8),
    ("flags", u8),
    ("bssid", sockaddr),
    ("essid", cchar * 32),
    ("min_channel_time", cuint),
    ("max_channel_time", cuint),
    ("channel_list", iw_freq * 32),
]


class iw_encode_ext(Struct):
    pass


iw_encode_ext._fields_ = [
    ("ext_flags", cuint),
    ("tx_seq", cchar * 8),
    ("rx_seq", cchar * 8),
    ("addr", sockaddr),
    ("alg", u16),
    ("key_len", u16),
    ("key", POINTER(cchar)),
]


class iw_mlme(Struct):
    pass


iw_mlme._fields_ = [("cmd", u16), ("reason_code", u16), ("addr", sockaddr)]


class iw_pmksa(Struct):
    pass


iw_pmksa._fields_ = [("cmd", cuint), ("bssid", sockaddr), ("pmkid", cchar * 16)]


class iw_michaelmicfailure(Struct):
    pass


iw_michaelmicfailure._fields_ = [("flags", cuint), ("src_addr", sockaddr), ("tsc", cchar * 8)]


class iw_pmkid_cand(Struct):
    pass


iw_pmkid_cand._fields_ = [("flags", cuint), ("index", cuint), ("bssid", sockaddr)]


class iw_statistics(Struct):
    pass


iw_statistics._fields_ = [("status", u16), ("qual", iw_quality), ("discard", iw_discarded), ("miss", iw_missed)]


class iwreq_data(Union):
    pass


iwreq_data._fields_ = [
    ("name", cchar * 16),
    ("essid", iw_point),
    ("nwid", iw_param),
    ("freq", iw_freq),
    ("sens", iw_param),
    ("bitrate", iw_param),
    ("txpower", iw_param),
    ("rts", iw_param),
    ("frag", iw_param),
    ("mode", cuint),
    ("retry", iw_param),
    ("encoding", iw_point),
    ("power", iw_param),
    ("qual", iw_quality),
    ("ap_addr", sockaddr),
    ("addr", sockaddr),
    ("param", iw_param),
    ("data", iw_point),
]


class iwreq(Struct):
    class M1(Union):
        _pack_ = True

    M1._fields_ = [("ifrn_name", cchar * 16)]


iwreq._fields_ = [("ifr_ifrn", iwreq.M1), ("u", iwreq_data)]


class iw_range(Struct):
    pass


iw_range._fields_ = [
    ("throughput", cuint),
    ("min_nwid", cuint),
    ("max_nwid", cuint),
    ("old_num_channels", u16),
    ("old_num_frequency", u8),
    ("scan_capa", u8),
    ("event_capa", cuint * 6),
    ("sensitivity", cint),
    ("max_qual", iw_quality),
    ("avg_qual", iw_quality),
    ("num_bitrates", u8),
    ("bitrate", cint * 32),
    ("min_rts", cint),
    ("max_rts", cint),
    ("min_frag", cint),
    ("max_frag", cint),
    ("min_pmp", cint),
    ("max_pmp", cint),
    ("min_pmt", cint),
    ("max_pmt", cint),
    ("pmp_flags", u16),
    ("pmt_flags", u16),
    ("pm_capa", u16),
    ("encoding_size", u16 * 8),
    ("num_encoding_sizes", u8),
    ("max_encoding_tokens", u8),
    ("encoding_login_index", u8),
    ("txpower_capa", u16),
    ("num_txpower", u8),
    ("txpower", cint * 8),
    ("we_version_compiled", u8),
    ("we_version_source", u8),
    ("retry_capa", u16),
    ("retry_flags", u16),
    ("r_time_flags", u16),
    ("min_retry", cint),
    ("max_retry", cint),
    ("min_r_time", cint),
    ("max_r_time", cint),
    ("num_channels", u16),
    ("num_frequency", u8),
    ("freq", iw_freq * 32),
    ("enc_capa", cuint),
]


class iw_priv_args(Struct):
    pass


iw_priv_args._fields_ = [("cmd", cuint), ("set_args", u16), ("get_args", u16), ("name", cchar * 16)]


class iw_event(Struct):
    pass


iw_event._fields_ = [("len", u16), ("cmd", u16), ("u", iwreq_data)]


class IOC(enum.IntEnum):
    ADDRT = 0x890B  # add routing table entry
    DELRT = 0x890C  # delete routing table entry
    RTMSG = 0x890D  # unused
    GIFNAME = 0x8910  # get iface name
    SIFLINK = 0x8911  # set iface channel
    GIFCONF = 0x8912  # get iface list
    GIFFLAGS = 0x8913  # get flags
    SIFFLAGS = 0x8914  # set flags
    GIFADDR = 0x8915  # get PA address
    SIFADDR = 0x8916  # set PA address
    GIFDSTADDR = 0x8917  # get remote PA address
    SIFDSTADDR = 0x8918  # set remote PA address
    GIFBRDADDR = 0x8919  # get broadcast PA address
    SIFBRDADDR = 0x891A  # set broadcast PA address
    GIFNETMASK = 0x891B  # get network PA mask
    SIFNETMASK = 0x891C  # set network PA mask
    GIFMETRIC = 0x891D  # get metric
    SIFMETRIC = 0x891E  # set metric
    GIFMEM = 0x891F  # get memory address (BSD)
    SIFMEM = 0x8920  # set memory address (BSD)
    GIFMTU = 0x8921  # get MTU size
    SIFMTU = 0x8922  # set MTU size
    SIFNAME = 0x8923  # setcinterface name
    SIFHWADDR = 0x8924  # set hardware address
    GIFENCAP = 0x8925  # get/set encapsulations
    SIFENCAP = 0x8926
    GIFHWADDR = 0x8927  # Get hardware address
    GIFSLAVE = 0x8929  # Driver slaving support
    SIFSLAVE = 0x8930
    ADDMULTI = 0x8931  # Multicast address lists
    DELMULTI = 0x8932
    GIFINDEX = 0x8933  # name -> if_index mapping
    SIFPFLAGS = 0x8934  # set/get extended flags set
    GIFPFLAGS = 0x8935
    DIFADDR = 0x8936  # delete PA address
    SIFHWBROADCAST = 0x8937  # set hardware broadcast addr
    GIFCOUNT = 0x8938  # get number of devices
    GIFBR = 0x8940  # Bridging support
    SIFBR = 0x8941  # Set bridging options
    GIFTXQLEN = 0x8942  # Get the tx queue length
    SIFTXQLEN = 0x8943  # Set the tx queue length
    ETHTOOL = 0x8946  # Ethtoolcinterface
    GMIIPHY = 0x8947  # Get address of MII PHY in use.
    GMIIREG = 0x8948  # Read MII PHY register.
    SMIIREG = 0x8949  # Write MII PHY register.
    WANDEV = 0x894A  # get/set netdev parameters
    OUTQNSD = 0x894B  # output queue size (not sent only)
    GSKNS = 0x894C  # get socket network namespace
    DARP = 0x8953  # delete ARP table entry
    GARP = 0x8954  # get ARP table entry
    SARP = 0x8955  # set ARP table entry
    DRARP = 0x8960  # delete RARP table entry
    GRARP = 0x8961  # get RARP table entry
    SRARP = 0x8962  # set RARP table entry
    GIFMAP = 0x8970  # Get device parameters
    SIFMAP = 0x8971  # Set device parameters
    ADDDLCI = 0x8980  # Create new DLCI device
    DELDLCI = 0x8981  # Delete DLCI device
    GIFVLAN = 0x8982  # 802.1Q VLAN support
    SIFVLAN = 0x8983  # Set 802.1Q VLAN options
    BONDENSLAVE = 0x8990  # enslave a device to the bond
    BONDRELEASE = 0x8991  # release a slave from the bond
    BONDSETHWADDR = 0x8992  # set the hw addr of the bond
    BONDSLAVEINFOQUERY = 0x8993  # rtn info about slave state
    BONDINFOQUERY = 0x8994  # rtn info about bond state
    BONDCHANGEACTIVE = 0x8995  # update to a new active slave
    BRADDBR = 0x89A0  # create new bridge device
    BRDELBR = 0x89A1  # remove bridge device
    BRADDIF = 0x89A2  # addcinterface to bridge
    BRDELIF = 0x89A3  # removecinterface from bridge
    SHWTSTAMP = 0x89B0  # set and get config
    GHWTSTAMP = 0x89B1  # get config
    SIWCOMMIT = 0x8B00  # Commit pending changes to driver
    GIWNAME = 0x8B01  # get name == wireless protocol
    SIWNWID = 0x8B02  # set network id (pre-802.11)
    GIWNWID = 0x8B03  # get network id (the cell)
    SIWFREQ = 0x8B04  # set channel/frequency (Hz)
    GIWFREQ = 0x8B05  # get channel/frequency (Hz)
    SIWMODE = 0x8B06  # set operation mode
    GIWMODE = 0x8B07  # get operation mode
    SIWSENS = 0x8B08  # set sensitivity (dBm)
    GIWSENS = 0x8B09  # get sensitivity (dBm)
    SIWRANGE = 0x8B0A  # Unused
    GIWRANGE = 0x8B0B  # Get range of parameters
    SIWPRIV = 0x8B0C  # Unused
    GIWPRIV = 0x8B0D  # get private ioctlcinterface info
    SIWSTATS = 0x8B0E  # Unused
    GIWSTATS = 0x8B0F  # Get /proc/net/wireless stats
    SIWSPY = 0x8B10  # set spy addresses
    GIWSPY = 0x8B11  # get spy info (quality of link)
    SIWTHRSPY = 0x8B12  # set spy threshold (spy event)
    GIWTHRSPY = 0x8B13  # get spy threshold
    SIWAP = 0x8B14  # set access point MAC addresses
    GIWAP = 0x8B15  # get access point MAC addresses
    GIWAPLIST = 0x8B17  # Deprecated in favor of scanning
    SIWSCAN = 0x8B18  # trigger scanning (list cells)
    GIWSCAN = 0x8B19  # get scanning results
    SIWESSID = 0x8B1A  # set ESSID (network name)
    GIWESSID = 0x8B1B  # get ESSID
    SIWNICKN = 0x8B1C  # set node name/nickname
    GIWNICKN = 0x8B1D  # get node name/nickname
    SIWRATE = 0x8B20  # set default bit rate (bps)
    GIWRATE = 0x8B21  # get default bit rate (bps)
    SIWRTS = 0x8B22  # set RTS/CTS threshold (bytes)
    GIWRTS = 0x8B23  # get RTS/CTS threshold (bytes)
    SIWFRAG = 0x8B24  # set fragmentation thr (bytes)
    GIWFRAG = 0x8B25  # get fragmentation thr (bytes)
    SIWTXPOW = 0x8B26  # set transmit power (dBm)
    GIWTXPOW = 0x8B27  # get transmit power (dBm)
    SIWRETRY = 0x8B28  # set retry limits and lifetime
    GIWRETRY = 0x8B29  # get retry limits and lifetime
    SIWENCODE = 0x8B2A  # set encoding token & mode
    GIWENCODE = 0x8B2B  # get encoding token & mode
    SIWPOWER = 0x8B2C  # set Power Management settings
    GIWPOWER = 0x8B2D  # get Power Management settings
    SIWGENIE = 0x8B30  # set generic IE
    GIWGENIE = 0x8B31  # get generic IE
    SIWMLME = 0x8B16  # request MLME operation; uses
    SIWAUTH = 0x8B32  # set authentication mode params
    GIWAUTH = 0x8B33  # get authentication mode params
    SIWENCODEEXT = 0x8B34  # set encoding token & mode
    GIWENCODEEXT = 0x8B35  # get encoding token & mode
    SIWPMKSA = 0x8B36  # PMKSA cache operation
    IWFIRSTPRIV = 0x8BE0
    IWLASTPRIV = 0x8BFF
    IWFIRST = 0x8B00
    IWLAST = IWLASTPRIV  # 0x8BFF

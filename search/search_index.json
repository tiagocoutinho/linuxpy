{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"\ud83d\udc27 Welcome to linuxpy","text":"<p>Human friendly interface to linux subsystems using python.</p> <p>Provides python access to several linux subsystems like V4L2, input, GPIO and MIDI.</p> <p>There is experimental, undocumented, incomplete and unstable access to USB.</p> <p>Need fine control over Webcams, GPIO, MIDI devices, thermal sensors and cooling devices, joysticks, gamepads, keyboards, mice or even the keyboard light on your laptop?</p> <p>Linuxpy has your back.</p> <p>Requirements:</p> <ul> <li>python &gt;= 3.9</li> <li>Fairly recent linux kernel</li> <li>Installed kernel modules you want to access (ex: uinput if you need user space created input devices)</li> </ul> <p>And yes, it is true: there are no python dependencies! Also there are no C libraries dependencies! Everything is done here through direct ioctl, read and write calls. Ain't linux wonderful?</p>"},{"location":"#goals","title":"Goals","text":"<ul> <li>A pure python library (no dependency on other C libraries)</li> <li>No third-party python dependencies (not a hard requirement)</li> <li>Fine-grain access to low level linux device capabilities</li> <li>For video (V4L2) this means:<ul> <li>List available devices</li> <li>Obtain detailed information about a device (name, driver,     capabilities, available formats)</li> <li>Fine control over the camera parameters (ex: resolution, format,     brightness, contrast, etc)</li> <li>Fine control resource management to take profit of memory map, DMA     or user pointers (buffers)</li> <li>Detailed information about a frame (timestamp, frame number, etc)</li> <li>Write to VideoOutput</li> <li>Integration with non blocking coroutine based applications (gevent     and asyncio) without the usual tricks like using <code>asyncio.to_thread()</code></li> </ul> </li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>From within your favorite python environment:</p> pip install linuxpy pip install linuxpy <p>To run the examples you'll need:</p> <pre><code>$ pip install linuxpy[examples]\n</code></pre> <p>To develop, run tests, build package, lint, etc you'll need:</p> <pre><code>$ pip install linuxpy[dev]\n</code></pre> <p>To run docs you'll need:</p> <pre><code>$ pip install linuxpy[docs]\n</code></pre>"},{"location":"#faq","title":"FAQ","text":"<p>Most python libraries try as hard as possible to be platform independent. Why create a library that is explicitly designed to work only on linux?</p> <p>Well, first of all, one of the goals is to be able to access low level linux device capabilities like video controls. Second, I don't have access to proprietary OS like Windows or MacOS.</p> <p>If this answer is not enough than think of this library as a low level dependency on linux systems of other libraries  that will be concerned with providing a common API on different platforms.</p>"},{"location":"develop/","title":"Developers corner","text":""},{"location":"develop/#requirements","title":"Requirements","text":"<p>A linux OS and python &gt;= 3.9.</p> <p>From within your favorite python environment:</p> <pre><code>$ pip install linuxpy[dev]\n</code></pre> <p>Additionally, to run the code generation tool you'll need <code>castxml</code> installed on your system.</p> <p>On a debian based run:</p> <pre><code>$ apt install castxml linux-headers-$(uname -r)\n</code></pre>"},{"location":"develop/#code-generation","title":"Code generation","text":"<p>This project uses an internal simple code generator that reads linux kernel header files and produces several <code>raw.py</code> ctypes based python files for each sub-system.</p> <p>To re-generate these files for a newer linux kernel (or fix a bug) you'll need linux header files installed on your system + black.</p> <p>To launch the tool call:</p> <pre><code>$ python -m linuxpy.codegen.cli\n</code></pre>"},{"location":"develop/#running-tests","title":"Running tests","text":"<p>First make sure your user belongs to <code>input</code> and <code>video</code> groups (create those groups if they don't exist):</p> <pre><code>$ sudo addgroup input\n$ sudo addgroup video\n$ sudo addgroup led\n$ sudo adduser $USER input\n$ sudo adduser $USER video\n$ sudo adduser $USER led\n</code></pre> <p>(reboot if necessary for those changes to take effect)</p> <p>Change the udev rules so these groups have access to the devices used by tests:</p> <p>Create a new rules file (ex: <code>/etc/udev/rules.d/80-device.rules</code>):</p> <pre><code>KERNEL==\"event[0-9]*\", SUBSYSTEM==\"input\", GROUP=\"input\", MODE:=\"0660\"\nKERNEL==\"uinput\", SUBSYSTEM==\"misc\", GROUP=\"input\", MODE:=\"0660\"\n\nSUBSYSTEM==\"video4linux\", GROUP=\"video\", MODE:=\"0660\"\n\nKERNEL==\"uleds\", GROUP=\"input\", MODE:=\"0660\"\nSUBSYSTEM==\"leds\", ACTION==\"add\", RUN+=\"/bin/chmod -R g=u,o=u /sys%p\"\nSUBSYSTEM==\"leds\", ACTION==\"change\", ENV{TRIGGER}!=\"none\", RUN+=\"/bin/chmod -R g=u,o=u /sys%p\"\n\nKERNEL==\"gpiochip[0-9]*\", SUBSYSTEM==\"gpio\", GROUP=\"input\", MODE=\"0660\"\nACTION==\"add\", SUBSYSTEM==\"configfs\", KERNEL==\"gpio-sim\", RUN+=\"/bin/chmod 775 /sys/kernel/config/gpio-sim/%k\"\nACTION==\"add\", SUBSYSTEM==\"configfs\", KERNEL==\"gpio-sim\", RUN+=\"/bin/chown root:input /sys/kernel/config/gpio-sim/%k\"\n</code></pre> <p>Reload the rules:</p> <pre><code>$ sudo udevadm control --reload-rules\n$ sudo udevadm trigger\n</code></pre> <p>Finally, make sure all kernel modules are installed:</p> <pre><code>$ sudo modprobe uinput\n$ sudo modprobe uleds\n$ sudo modprobe -r vivid\n$ sudo modprobe vivid n_devs=1 vid_cap_nr=190 vid_out_nr=191 meta_cap_nr=192 meta_out_nr=193\n$ sudo modprobe gpio-sim\n$ sudo python scripts/setup-gpio-sim.py\n</code></pre>"},{"location":"api/","title":"LinuxPy reference API","text":"<p>Here's the reference or code API, the classes, functions, parameters, attributes, and all the LinuxPy parts you can use in your applications.</p> <p>If you want to learn LinuxPy you are much better off reading the LinuxPy User Guide.</p>"},{"location":"api/device/","title":"Device","text":""},{"location":"api/device/#linuxpy.device","title":"<code>linuxpy.device</code>","text":""},{"location":"api/device/#linuxpy.device.ReentrantOpen","title":"<code>ReentrantOpen()</code>","text":"<p>               Bases: <code>AbstractContextManager</code></p> <p>Base for a reusable, reentrant (but not thread safe) open/close context manager</p>"},{"location":"api/device/#linuxpy.device.ReentrantOpen.open","title":"<code>open()</code>","text":"<p>Mandatory override for concrete sub-class</p>"},{"location":"api/device/#linuxpy.device.ReentrantOpen.close","title":"<code>close()</code>","text":"<p>Mandatory override for concrete sub-class</p>"},{"location":"api/device/#linuxpy.device.BaseDevice","title":"<code>BaseDevice(name_or_file, read_write=True, io=IO)</code>","text":"<p>               Bases: <code>ReentrantOpen</code></p> <p>Base class for a reentrant device</p>"},{"location":"api/device/#linuxpy.device.BaseDevice.closed","title":"<code>closed: bool</code>  <code>property</code>","text":"<p>True if the stream is closed. Always succeeds</p>"},{"location":"api/device/#linuxpy.device.BaseDevice.is_blocking","title":"<code>is_blocking: bool</code>  <code>property</code>","text":"<p>True if the underlying OS is opened in blocking mode. Raises error if device is not opened.</p>"},{"location":"api/device/#linuxpy.device.BaseDevice.from_id","title":"<code>from_id(did: int, **kwargs)</code>  <code>classmethod</code>","text":"<p>Create a new Device from the given id</p>"},{"location":"api/device/#linuxpy.device.BaseDevice.open","title":"<code>open()</code>","text":"<p>Open the device if not already open. Triggers _on_open after the underlying OS open has succeeded</p>"},{"location":"api/device/#linuxpy.device.BaseDevice.close","title":"<code>close()</code>","text":"<p>Closes the device if not already closed. Triggers _on_close before the underlying OS open has succeeded</p>"},{"location":"api/device/#linuxpy.device.BaseDevice.fileno","title":"<code>fileno() -&gt; int</code>","text":"<p>Return the underlying file descriptor (an integer) of the stream if it exists</p>"},{"location":"api/device/#linuxpy.device.device_number","title":"<code>device_number(path: PathLike) -&gt; Optional[int]</code>","text":"<p>Retrieves device number from a path like. Example: gives 12 for /dev/video12</p>"},{"location":"api/device/#linuxpy.device.is_device_file","title":"<code>is_device_file(path: PathLike, read_write: bool = True)</code>","text":"<p>Check if path like is a readable (and, optionally, writable) character device.</p>"},{"location":"api/device/#linuxpy.device.iter_device_files","title":"<code>iter_device_files(path: PathLike = '/dev', pattern: str = '*') -&gt; Iterable[pathlib.Path]</code>","text":"<p>Iterable of accessible (read &amp; write) char device files under the given path</p>"},{"location":"api/gpio/","title":"\u26a1 GPIO API","text":""},{"location":"api/gpio/#linuxpy.gpio.device","title":"<code>linuxpy.gpio.device</code>","text":"<p>Human friendly interface to linux GPIO subsystem.</p> <p>The heart of linuxpy GPIO library is the <code>Device</code> class. The recommended way is to use one of the find methods to create a Device object and use it within a context manager like:</p> <pre><code>from linuxpy.gpio.device import find, LineFlag\n\nwith find() as gpio:\n    # request lines 5 and 6\n    lines = gpio[5, 6]\n    lines.flags = LineFlag.ACTIVE_LOW\n    with lines:\n        print(lines[:])\n</code></pre>"},{"location":"api/gpio/#linuxpy.gpio.device.Request","title":"<code>Request(device, config: dict, blocking: bool = False)</code>","text":"<p>               Bases: <code>ReentrantOpen</code></p> <p>A lazy request to reserve lines on a chip</p> <p>Prefered creation from the <code>Device.request()</code> method.</p>"},{"location":"api/gpio/#linuxpy.gpio.device.Request.name","title":"<code>name: str</code>  <code>property</code> <code>writable</code>","text":"<p>Requestor name</p> <p>Change the requestor name must be called before the request is open to take effect</p> RETURNS DESCRIPTION <code>str</code> <p>consumer name</p> <p> TYPE: <code>str</code> </p>"},{"location":"api/gpio/#linuxpy.gpio.device.Request.min_line","title":"<code>min_line: int</code>  <code>property</code>","text":"<p>The smallest line number in the request</p> RETURNS DESCRIPTION <code>int</code> <p>The smallest line number in the request</p> <p> TYPE: <code>int</code> </p>"},{"location":"api/gpio/#linuxpy.gpio.device.Request.max_line","title":"<code>max_line: int</code>  <code>property</code>","text":"<p>The biggest line number in the request</p> RETURNS DESCRIPTION <code>int</code> <p>The biggest line number in the request</p> <p> TYPE: <code>int</code> </p>"},{"location":"api/gpio/#linuxpy.gpio.device.Request.__getitem__","title":"<code>__getitem__(key: Union[int, tuple, slice]) -&gt; Union[int, dict]</code>","text":"<p>Reads lines values</p> PARAMETER DESCRIPTION <code>key</code> <p>a line number, a slice, or a list of line numbers or slices</p> <p> TYPE: <code>Union[int, tuple, slice]</code> </p> RETURNS DESCRIPTION <code>Union[int, dict]</code> <p>Union[int, dict]: a dict where key is line number and value its value</p>"},{"location":"api/gpio/#linuxpy.gpio.device.Request.__setitem__","title":"<code>__setitem__(key: Union[int, tuple, slice], value: Union[int, Sequence[int]])</code>","text":"<p>Sets the given lines values</p> PARAMETER DESCRIPTION <code>key</code> <p>a line number, a slice, or a list of line numbers or slices</p> <p> TYPE: <code>Union[int, tuple, slice]</code> </p> <code>value</code> <p>the value(s) to write for the given lines</p> <p> TYPE: <code>Union[int, Sequence[int]]</code> </p> RAISES DESCRIPTION <code>ValueError</code> <p>if key is a line number and value is not a number (0 or 1)</p>"},{"location":"api/gpio/#linuxpy.gpio.device.Request.__iter__","title":"<code>__iter__() -&gt; Iterable[LineEvent]</code>","text":"<p>Infinite stream of line events</p> RETURNS DESCRIPTION <code>Iterable[LineEvent]</code> <p>Iterable[LineEvent]: the stream of events</p>"},{"location":"api/gpio/#linuxpy.gpio.device.Request.__aiter__","title":"<code>__aiter__() -&gt; AsyncIterator[LineEvent]</code>","text":"<p>Asynchronous stream of line events</p> RETURNS DESCRIPTION <code>AsyncIterator[LineEvent]</code> <p>AsyncIterator[LineEvent]: the asynchronous stream of events</p>"},{"location":"api/gpio/#linuxpy.gpio.device.Request.filenos","title":"<code>filenos() -&gt; list[int]</code>","text":"<p>List of underlying request file numbers</p> RETURNS DESCRIPTION <code>list[int]</code> <p>list[int]: List of underlying request file numbers</p>"},{"location":"api/gpio/#linuxpy.gpio.device.Request.close","title":"<code>close()</code>","text":"<p>Closes the underling request files. If request is not open nothing is done.</p>"},{"location":"api/gpio/#linuxpy.gpio.device.Request.open","title":"<code>open()</code>","text":"<p>Opens the underling request files effectively reserving the lines</p>"},{"location":"api/gpio/#linuxpy.gpio.device.Request.get_values","title":"<code>get_values(lines: Optional[Sequence[int]] = None) -&gt; dict[int, int]</code>","text":"<p>Reads values for the given lines</p> PARAMETER DESCRIPTION <code>lines</code> <p>A collection of lines. Defaults to None. Default means read all lines</p> <p> TYPE: <code>Optional[Sequence[int]]</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>dict[int, int]</code> <p>dict[int, int]: line values. Key is line number and value its value</p>"},{"location":"api/gpio/#linuxpy.gpio.device.Request.set_values","title":"<code>set_values(values: dict[int, Union[int, bool]])</code>","text":"<p>Writes new values on the given lines</p> PARAMETER DESCRIPTION <code>values</code> <p>key is line number and value its value</p> <p> TYPE: <code>dict[int, Union[int, bool]]</code> </p>"},{"location":"api/gpio/#linuxpy.gpio.device.Device","title":"<code>Device(*args, **kwargs)</code>","text":"<p>               Bases: <code>BaseDevice</code></p> <p>A device represents a connection to the underlying gpio chip</p>"},{"location":"api/gpio/#linuxpy.gpio.device.Device.__len__","title":"<code>__len__() -&gt; int</code>","text":"<p>The number of lines in this chip</p> RETURNS DESCRIPTION <code>int</code> <p>The number of lines in this chip</p> <p> TYPE: <code>int</code> </p>"},{"location":"api/gpio/#linuxpy.gpio.device.Device.__getitem__","title":"<code>__getitem__(key: Union[int, tuple, slice]) -&gt; Request</code>","text":"<p>create a request for the given lines. Equivalent to <code>device.request(key)</code></p> <p>Note</p> <p>The request is not active after this call. You need to use the request object returned by this method in a context manager or manually call open/close.</p> PARAMETER DESCRIPTION <code>key</code> <p>the line number, slice or a list of line numbers, or slices</p> <p> TYPE: <code>Union[int, tuple, slice]</code> </p> RETURNS DESCRIPTION <code>Request</code> <p>A new request object</p> <p> TYPE: <code>Request</code> </p>"},{"location":"api/gpio/#linuxpy.gpio.device.Device.__iter__","title":"<code>__iter__() -&gt; Iterable[LineInfoEvent]</code>","text":"<p>Infinite stream of line config events</p> RETURNS DESCRIPTION <code>Iterable[LineInfoEvent]</code> <p>Iterable[LineInfoEvent]: the stream of line config events</p>"},{"location":"api/gpio/#linuxpy.gpio.device.Device.__aiter__","title":"<code>__aiter__() -&gt; AsyncIterator[LineInfoEvent]</code>","text":"<p>Asynchronous stream of line events</p> RETURNS DESCRIPTION <code>AsyncIterator[LineInfoEvent]</code> <p>AsyncIterator[LineInfoEvent]: the asynchronous stream of line info events</p>"},{"location":"api/gpio/#linuxpy.gpio.device.Device.info_stream","title":"<code>info_stream(lines: Collection[int]) -&gt; Iterable[LineInfoEvent]</code>","text":"<p>Register for watching line config events on the given lines and stream them</p> PARAMETER DESCRIPTION <code>lines</code> <p>line numbers to watch for config events</p> <p> TYPE: <code>Collection[int]</code> </p> RETURNS DESCRIPTION <code>Iterable[LineInfoEvent]</code> <p>Iterable[LineInfoEvent]: the stream of line config events</p>"},{"location":"api/gpio/#linuxpy.gpio.device.Device.async_info_stream","title":"<code>async_info_stream(lines: Collection[int]) -&gt; AsyncIterator[LineInfoEvent]</code>  <code>async</code>","text":"<p>Register for watching line config events on the given lines and async stream them</p> PARAMETER DESCRIPTION <code>lines</code> <p>line numbers to watch for config events</p> <p> TYPE: <code>Collection[int]</code> </p> RETURNS DESCRIPTION <code>AsyncIterator[LineInfoEvent]</code> <p>AsyncIterator[LineInfoEvent]: the asynchronous stream of line info events</p>"},{"location":"api/gpio/#linuxpy.gpio.device.Device.get_info","title":"<code>get_info() -&gt; Info</code>","text":"<p>Reads all information available including chip info and detailed information about each chip line information</p> RETURNS DESCRIPTION <code>Info</code> <p>The full chip information</p> <p> TYPE: <code>Info</code> </p>"},{"location":"api/gpio/#linuxpy.gpio.device.Device.watch_line","title":"<code>watch_line(line: int)</code>","text":"<p>Register the given line for config events</p> PARAMETER DESCRIPTION <code>line</code> <p>the line number to register</p> <p> TYPE: <code>int</code> </p>"},{"location":"api/gpio/#linuxpy.gpio.device.Device.unwatch_line","title":"<code>unwatch_line(line: int)</code>","text":"<p>Unregister the given line from config events</p> PARAMETER DESCRIPTION <code>line</code> <p>the line number to unregister</p> <p> TYPE: <code>int</code> </p>"},{"location":"api/gpio/#linuxpy.gpio.device.Device.watch_lines","title":"<code>watch_lines(lines: Collection[int])</code>","text":"<p>Register the given lines for config events</p> PARAMETER DESCRIPTION <code>lines</code> <p>the line numbers to register</p> <p> TYPE: <code>Collection[int]</code> </p>"},{"location":"api/gpio/#linuxpy.gpio.device.Device.unwatch_lines","title":"<code>unwatch_lines(lines: Collection[int])</code>","text":"<p>Unregister the given lines from config events</p> PARAMETER DESCRIPTION <code>lines</code> <p>the lines number to unregister</p> <p> TYPE: <code>Collection[int]</code> </p>"},{"location":"api/gpio/#linuxpy.gpio.device.Device.watching","title":"<code>watching(lines)</code>","text":"<p>A context manager during which the given lines are registered for line config events</p> PARAMETER DESCRIPTION <code>lines</code> <p>the line numbers to listen for config events</p> <p> TYPE: <code>_type_</code> </p>"},{"location":"api/gpio/#linuxpy.gpio.device.Device.request","title":"<code>request(config: Optional[Union[Collection, list]] = None, blocking: Union[bool, object] = sentinel) -&gt; Request</code>","text":"<p>Create a request to reserve a list of lines on this chip</p> <p>Note</p> <p>The request is not active after this call. You need to use the request object returned by this method in a context manager or manually call open/close.</p> PARAMETER DESCRIPTION <code>config</code> <p>lines configuration</p> <p> TYPE: <code>dict</code> DEFAULT: <code>None</code> </p> <code>lines</code> <p>blocking mode</p> <p> TYPE: <code>Union[bool, sentinel]</code> </p> RETURNS DESCRIPTION <code>Request</code> <p>A new request object</p> <p> TYPE: <code>Request</code> </p>"},{"location":"api/gpio/#linuxpy.gpio.device.get_chip_info","title":"<code>get_chip_info(fd: FDLike) -&gt; ChipInfo</code>","text":"<p>Reads the chip information</p> PARAMETER DESCRIPTION <code>fd</code> <p>a gpiochip file number or file like object</p> <p> TYPE: <code>FDLike</code> </p> RETURNS DESCRIPTION <code>ChipInfo</code> <p>chip info of the given file descriptor</p> <p> TYPE: <code>ChipInfo</code> </p>"},{"location":"api/gpio/#linuxpy.gpio.device.get_line_info","title":"<code>get_line_info(fd: FDLike, line: int) -&gt; LineInfo</code>","text":"<p>Reads the given line information</p> PARAMETER DESCRIPTION <code>fd</code> <p>a gpiochip file number or file like object</p> <p> TYPE: <code>FDLike</code> </p> <code>line</code> <p>desired line to get information</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>LineInfo</code> <p>information for the given line and chip</p> <p> TYPE: <code>LineInfo</code> </p>"},{"location":"api/gpio/#linuxpy.gpio.device.get_info","title":"<code>get_info(fd: FDLike) -&gt; Info</code>","text":"<p>Reads the given chip the full information</p> PARAMETER DESCRIPTION <code>fd</code> <p>a gpiochip file number or file like object</p> <p> TYPE: <code>FDLike</code> </p> RETURNS DESCRIPTION <code>Info</code> <p>information for the given chip including all its lines</p> <p> TYPE: <code>Info</code> </p>"},{"location":"api/gpio/#linuxpy.gpio.device.request","title":"<code>request(fd: FDLike, config: dict, blocking: bool = False) -&gt; raw.gpio_v2_line_request</code>","text":"<p>Make a request to reserve the given line(s)</p> PARAMETER DESCRIPTION <code>fd</code> <p>a gpiochip file number or file like object</p> <p> TYPE: <code>FDLike</code> </p> <code>config</code> <p>line config as specified in GPIO line configuration request</p> <p> TYPE: <code>dict</code> </p> <code>blocking</code> <p>Make the return FD blocking. Defaults to False.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>gpio_v2_line_request</code> <p>raw.gpio_v2_line_request: The details of the request. Field <code>fd</code> contains the new open file descritor</p>"},{"location":"api/gpio/#linuxpy.gpio.device.get_values","title":"<code>get_values(req_fd: FDLike, mask: int) -&gt; raw.gpio_v2_line_values</code>","text":"<p>Read lines values.</p> PARAMETER DESCRIPTION <code>req_fd</code> <p>a gpiochip file number or file like object</p> <p> TYPE: <code>FDLike</code> </p> <code>mask</code> <p>a bitmap identifying the lines, with each bit number corresponding to         the index of the line reserved in the given req_fd.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>gpio_v2_line_values</code> <p>raw.gpio_v2_line_values: the current line values</p>"},{"location":"api/gpio/#linuxpy.gpio.device.set_values","title":"<code>set_values(req_fd: FDLike, mask: int, bits: int) -&gt; raw.gpio_v2_line_values</code>","text":"<p>Set lines values.</p> PARAMETER DESCRIPTION <code>req_fd</code> <p>a gpiochip file number or file like object</p> <p> TYPE: <code>FDLike</code> </p> <code>mask</code> <p>The mask is a bitmap identifying the lines, with each bit number corresponding to   the index of the line reserved in the given req_fd.</p> <p> TYPE: <code>int</code> </p> <code>bits</code> <p>The bits is a bitmap containing the value of the lines, set to 1 for active and 0   for inactive.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>gpio_v2_line_values</code> <p>raw.gpio_v2_line_values: the underlying object sent to the ioctl call</p>"},{"location":"api/gpio/#linuxpy.gpio.device.read_one_event","title":"<code>read_one_event(req_fd: FDLike) -&gt; LineEvent</code>","text":"<p>Read one event from the given request file descriptor</p> PARAMETER DESCRIPTION <code>req_fd</code> <p>description</p> <p> TYPE: <code>FDLike</code> </p> RETURNS DESCRIPTION <code>LineEvent</code> <p>description</p> <p> TYPE: <code>LineEvent</code> </p>"},{"location":"api/gpio/#linuxpy.gpio.device.expand_from_list","title":"<code>expand_from_list(key: Union[int, slice, tuple], minimum, maximum) -&gt; list[int]</code>","text":"<p>Used internally in getitem to expand the given key</p>"},{"location":"api/gpio/#linuxpy.gpio.device.iter_gpio_files","title":"<code>iter_gpio_files(path: PathLike = '/dev') -&gt; Iterable[pathlib.Path]</code>","text":"<p>Returns an iterator over all GPIO chip files.</p> <p>Warning</p> <p>Only files for which the current user has read and write access are returned</p> PARAMETER DESCRIPTION <code>path</code> <p>root path. Defaults to \"/dev\".</p> <p> TYPE: <code>PathLike</code> DEFAULT: <code>'/dev'</code> </p> RETURNS DESCRIPTION <code>Iterable[Path]</code> <p>Iterable[pathlib.Path]: an iterator over the gpiochip files found on the system</p>"},{"location":"api/gpio/#linuxpy.gpio.device.iter_devices","title":"<code>iter_devices(path: PathLike = '/dev', **kwargs) -&gt; Iterable[Device]</code>","text":"<p>Returns an iterator over all GPIO chip devices</p> PARAMETER DESCRIPTION <code>path</code> <p>root path. Defaults to \"/dev\".</p> <p> TYPE: <code>PathLike</code> DEFAULT: <code>'/dev'</code> </p> RETURNS DESCRIPTION <code>Iterable[Device]</code> <p>Iterable[Device]:  an iterator over the gpiochip devices found on the system</p>"},{"location":"api/input/","title":"\ud83d\udd79\ufe0f Input API","text":""},{"location":"api/input/#linuxpy.input.device","title":"<code>linuxpy.input.device</code>","text":"<p>Human friendly interface to linux Input subsystem.</p> <p>The heart of linuxpy input library is the <code>Device</code> class. The recommended way is to use one of the find methods to create a Device object and use it within a context manager like:</p> <pre><code>from linuxpy.input.device import find_gamepad\n\nwith find_gamepad() as gamepad:\n    print(f\"Gamepad name: {gamepad.name}\")\n</code></pre>"},{"location":"api/input/#linuxpy.input.device.InputError","title":"<code>InputError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Input error</p>"},{"location":"api/input/#linuxpy.input.device.Event","title":"<code>Event(event: input_event)</code>","text":"<p>Event generated by an input device</p>"},{"location":"api/input/#linuxpy.input.device.Event.timestamp","title":"<code>timestamp: float</code>  <code>property</code>","text":"<p>The timestamp associated with the event</p>"},{"location":"api/input/#linuxpy.input.device.Event.type","title":"<code>type: EventType</code>  <code>property</code>","text":"<p>The type of event</p>"},{"location":"api/input/#linuxpy.input.device.Event.code","title":"<code>code</code>  <code>property</code>","text":"<p>The event code</p>"},{"location":"api/input/#linuxpy.input.device.Event.value","title":"<code>value: int</code>  <code>property</code>","text":"<p>The event value</p>"},{"location":"api/input/#linuxpy.input.device.Device","title":"<code>Device(*args, **kwargs)</code>","text":"<p>               Bases: <code>BaseDevice</code></p> <p>Central linux input subsystem class.</p> <p>You can create an instance directly if you know the device name:</p> <pre><code>from linuxpy.input.device import Device\n\nwith Device(\"/dev/input11\") as i11:\n    print(i11.name)\n</code></pre> <p>... but it is generally easier to use the <code>find</code> helper to get a device with a certain condition. Example:</p> <pre><code>from linuxpy.input.device import find\n\ntrack_point = find(name=\"TPPS/2 Elan TrackPoint\")\n</code></pre>"},{"location":"api/input/#linuxpy.input.device.Device.name","title":"<code>name: str</code>  <code>cached</code> <code>property</code>","text":"<p>The device name</p>"},{"location":"api/input/#linuxpy.input.device.Device.version","title":"<code>version: Version</code>  <code>cached</code> <code>property</code>","text":"<p>The version</p>"},{"location":"api/input/#linuxpy.input.device.Device.physical_location","title":"<code>physical_location: str</code>  <code>cached</code> <code>property</code>","text":"<p>The physical location</p>"},{"location":"api/input/#linuxpy.input.device.Device.device_id","title":"<code>device_id: input_id</code>  <code>cached</code> <code>property</code>","text":"<p>The device input ID</p>"},{"location":"api/input/#linuxpy.input.device.Device.capabilities","title":"<code>capabilities</code>  <code>cached</code> <code>property</code>","text":"<p>The device capabilities</p>"},{"location":"api/input/#linuxpy.input.device.Device.active_keys","title":"<code>active_keys</code>  <code>property</code>","text":"<p>All active keys at the moment of calling this</p>"},{"location":"api/input/#linuxpy.input.device.Device.x","title":"<code>x</code>  <code>property</code>","text":"<p>Current absolute X value</p>"},{"location":"api/input/#linuxpy.input.device.Device.y","title":"<code>y</code>  <code>property</code>","text":"<p>Current absolute Y value</p>"},{"location":"api/input/#linuxpy.input.device.Device.z","title":"<code>z</code>  <code>property</code>","text":"<p>Current absolute Z value</p>"},{"location":"api/input/#linuxpy.input.device.Device.rx","title":"<code>rx</code>  <code>property</code>","text":"<p>Current relative X value</p>"},{"location":"api/input/#linuxpy.input.device.Device.ry","title":"<code>ry</code>  <code>property</code>","text":"<p>Current relative Y value</p>"},{"location":"api/input/#linuxpy.input.device.Device.rz","title":"<code>rz</code>  <code>property</code>","text":"<p>Current relative Z value</p>"},{"location":"api/input/#linuxpy.input.device.Device.__iter__","title":"<code>__iter__() -&gt; Iterable[Event]</code>","text":"<p>Build an infinite iterator that streams input events. You'll need an open Device before using it:</p> <pre><code>from linuxpy.input.device import find_mouse\n\nwith find_mouse() as mouse:\n    for event in mouse:\n        print(event)\n</code></pre>"},{"location":"api/input/#linuxpy.input.device.Device.__aiter__","title":"<code>__aiter__() -&gt; AsyncIterable[Event]</code>  <code>async</code>","text":"<p>Build an infinite async iterator that streams input events. You'll need an open Device before using it:</p> <pre><code>import asyncio\nfrom linuxpy.input.device import find_mouse\n\nasync def main():\n    with find_mouse() as mouse:\n        async for event in mouse:\n            print(event)\n\nasyncio.run(main())\n</code></pre>"},{"location":"api/input/#linuxpy.input.device.Device.get_abs_info","title":"<code>get_abs_info(abs_code)</code>","text":"<p>Absolute information for the given abs code</p>"},{"location":"api/input/#linuxpy.input.device.Device.read_event","title":"<code>read_event()</code>","text":"<p>Read event. Event must be available to read or otherwise will raise an error</p>"},{"location":"api/input/#linuxpy.input.device.Device.grab","title":"<code>grab()</code>","text":"<p>Grab the device for exclusive use</p>"},{"location":"api/input/#linuxpy.input.device.Device.ungrab","title":"<code>ungrab()</code>","text":"<p>Release (ungrab) the device</p>"},{"location":"api/input/#linuxpy.input.device.Grab","title":"<code>Grab(device: Device)</code>","text":"<p>Context manager which grabs the device on enter and releases (ungrabs) it on exit.</p> <p>The device should be open for operation before the object is called on the <code>with</code> statement.</p> <p>This context manager is reusable but not reentrant and not thread safe.</p> <p>Example:</p> <pre><code>from linuxpy.input.device import find_mouse, Grab\nwith find_mouse() as mouse:\n    with Grab(mouse):\n        print(mouse.active_keys)\n</code></pre>"},{"location":"api/input/#linuxpy.input.device.BaseUDevice","title":"<code>BaseUDevice(filename=PATH, bus=Bus.VIRTUAL, vendor_id=1, product_id=1, name='linuxpy emulated device')</code>","text":"<p>               Bases: <code>BaseDevice</code></p> <p>A uinput device with no capabilities registered</p>"},{"location":"api/input/#linuxpy.input.device.iter_input_files","title":"<code>iter_input_files(path: PathLike = '/dev/input', pattern: str = 'event*')</code>","text":"<p>List readable character devices in the given path.</p>"},{"location":"api/input/#linuxpy.input.device.event_batch_stream","title":"<code>event_batch_stream(fd) -&gt; Iterable[Sequence[Event]]</code>","text":"<p>Yields packets of events occurring at the same moment in time.</p>"},{"location":"api/input/#linuxpy.input.device.async_event_batch_stream","title":"<code>async_event_batch_stream(fd, maxsize: int = 1000) -&gt; AsyncIterable[Sequence[Event]]</code>  <code>async</code>","text":"<p>Yields packets of events occurring at the same moment in time.</p>"},{"location":"api/input/#linuxpy.input.device.find","title":"<code>find(find_all: bool = False, custom_match: Optional[Callable] = None, **kwargs) -&gt; Union[Device, Iterable[Device], None]</code>","text":"<p>If find_all is False:</p> <p>Find a device follwing the criteria matched by custom_match and kwargs. If no device is found matching the criteria it returns None. Default is to return a random first device.</p> <p>If find_all is True:</p> <p>The result is an iterator. Find all devices that match the criteria custom_match and kwargs. If no device is found matching the criteria it returns an empty iterator. Default is to return an iterator over all input devices found on the system.</p>"},{"location":"api/input/#linuxpy.input.device.find_gamepad","title":"<code>find_gamepad(find_all: bool = False, custom_match: Optional[Callable] = None, **kwargs) -&gt; Union[Device, Iterable[Device], None]</code>","text":"<p>If find_all is False:</p> <p>Find a gamepad device follwing the criteria matched by custom_match and kwargs. If no device is found matching the criteria it returns None. Default is to return a random first gamepad.</p> <p>If find_all is True:</p> <p>The result is an iterator. Find all gamepad devices that match the criteria custom_match and kwargs. If no gamepad is found matching the criteria it returns an empty iterator. Default is to return an iterator over all gamepad devices found on the system.</p>"},{"location":"api/input/#linuxpy.input.device.find_keyboard","title":"<code>find_keyboard(find_all: bool = False, custom_match: Optional[Callable] = None, **kwargs) -&gt; Union[Device, Iterable[Device], None]</code>","text":"<p>If find_all is False:</p> <p>Find a keyboard device follwing the criteria matched by custom_match and kwargs. If no device is found matching the criteria it returns None. Default is to return a random first keyboard.</p> <p>If find_all is True:</p> <p>The result is an iterator. Find all keyboard devices that match the criteria custom_match and kwargs. If no keyboard is found matching the criteria it returns an empty iterator. Default is to return an iterator over all keyboard devices found on the system.</p>"},{"location":"api/input/#linuxpy.input.device.find_mouse","title":"<code>find_mouse(find_all: bool = False, custom_match: Optional[Callable] = None, **kwargs) -&gt; Union[Device, Iterable[Device], None]</code>","text":"<p>If find_all is False:</p> <p>Find a mouse device follwing the criteria matched by custom_match and kwargs. If no device is found matching the criteria it returns None. Default is to return a random first mouse.</p> <p>If find_all is True:</p> <p>The result is an iterator. Find all mouse devices that match the criteria custom_match and kwargs. If no mouse is found matching the criteria it returns an empty iterator. Default is to return an iterator over all mouse devices found on the system.</p>"},{"location":"api/led/","title":"\ud83d\udca1 Led API","text":""},{"location":"api/led/#linuxpy.led","title":"<code>linuxpy.led</code>","text":"<p>Human friendly interface to linux LED subsystem.</p> <pre><code>from linuxpy.led import find\n\ncaps_lock = find(function=\"capslock\")\nprint(caps_lock.brightness)\ncaps_lock.brightness = caps_lock.max_brightness\n</code></pre>"},{"location":"api/led/#linuxpy.led--uled","title":"ULED","text":"<pre><code>from linuxpy.led import LED, ULED\n\nwith ULED(\"uled::simulation\") as uled:\n    led = LED.from_name(\"uled::simulation\")\n    print()\n</code></pre> <p>Streaming example:</p> <pre><code>from time import monotonic\n\nfrom linuxpy.led import ULED\n\nwith ULED(\"uled::simulation\", max_brightness=100) as uled:\n    # Open another terminal and type:\n    # echo 10 &gt; /sys/class/leds/uled::simulation/brightness\n    for brightness in uled.stream():\n        print(f\"[{monotonic():.6f}]: {brightness}\")\n</code></pre>"},{"location":"api/led/#linuxpy.led.LED","title":"<code>LED(syspath: os.PathLike)</code>","text":"<p>               Bases: <code>Device</code></p> <p>Main LED class</p>"},{"location":"api/led/#linuxpy.led.LED.name","title":"<code>name: str</code>  <code>property</code>","text":"<p>LED name from the naming"},{"location":"api/led/#linuxpy.led.LED.devicename","title":"<code>devicename: str</code>  <code>property</code>","text":"<p>LED device name from the naming"},{"location":"api/led/#linuxpy.led.LED.color","title":"<code>color: str</code>  <code>property</code>","text":"<p>LED color from the naming"},{"location":"api/led/#linuxpy.led.LED.function","title":"<code>function: str</code>  <code>property</code>","text":"<p>LED function from the naming"},{"location":"api/led/#linuxpy.led.LED.trigger_enabled","title":"<code>trigger_enabled: bool</code>  <code>property</code>","text":"<p>Tells if the LED trigger is enabled</p>"},{"location":"api/led/#linuxpy.led.LED.from_name","title":"<code>from_name(name) -&gt; LED</code>  <code>classmethod</code>","text":"<p>Create a LED from the name that corresponds /sys/class/leds/"},{"location":"api/led/#linuxpy.led.ULED","title":"<code>ULED(name: str, max_brightness: int = 1, **kwargs)</code>","text":"<p>               Bases: <code>BaseDevice</code></p> <p>LED class for th userspace LED. This can be useful for testing triggers and can also be used to implement virtual LEDs.</p>"},{"location":"api/led/#linuxpy.led.ULED.brightness","title":"<code>brightness: int</code>  <code>property</code>","text":"<p>Read new brightness. Blocks until brightness changes</p>"},{"location":"api/led/#linuxpy.led.ULED.read","title":"<code>read() -&gt; bytes</code>","text":"<p>Read new brightness. Blocks until brightness changes</p>"},{"location":"api/led/#linuxpy.led.ULED.stream","title":"<code>stream() -&gt; Iterable[int]</code>","text":"<p>Infinite stream of brightness change events</p>"},{"location":"api/led/#linuxpy.led.iter_device_paths","title":"<code>iter_device_paths() -&gt; Iterable[pathlib.Path]</code>","text":"<p>Iterable of all LED syspaths (/sys/class/leds)</p>"},{"location":"api/led/#linuxpy.led.iter_devices","title":"<code>iter_devices() -&gt; Iterable[LED]</code>","text":"<p>Iterable over all LED devices</p>"},{"location":"api/led/#linuxpy.led.find","title":"<code>find(find_all: bool = False, custom_match: Optional[Callable] = None, **kwargs) -&gt; Union[LED, Iterable[LED], None]</code>","text":"<p>If find_all is False:</p> <p>Find a LED follwing the criteria matched by custom_match and kwargs. If no LED is found matching the criteria it returns None. Default is to return a random LED device.</p> <p>If find_all is True:</p> <p>The result is an iterator. Find all LEDs that match the criteria custom_match and kwargs. If no LED is found matching the criteria it returns an empty iterator. Default is to return an iterator over all LEDs found on the system.</p>"},{"location":"api/midi/","title":"\ud83c\udfb9 MIDI API","text":""},{"location":"api/midi/#linuxpy.midi.device","title":"<code>linuxpy.midi.device</code>","text":"<p>Human friendly interface to linux MIDI subsystem.</p> <p>The heart of linuxpy MIDI library is the <code>Sequencer</code> class. Usually you need only one instance of Sequencer for your application. The recommended way is to use it within a context manager like:</p> <pre><code>with Sequencer(\"My MIDI App\") as midi:\n    print(f\"MIDI version: {midi.version}\")\n</code></pre> <p>which is roughly equivalent to:</p> <pre><code>midi = Sequencer(\"My MIDI App\")\nmidi.open()\ntry:\n    print(f\"MIDI version: {midi.version}\")\nfinally:\n    midi.close()\n</code></pre> <p>Here's a real world example:</p> <pre><code>from linuxpy.midi.device import Sequencer\n\nwith Sequencer(\"My MIDI App\") as midi:\n    print(f\"I'm client {midi.client_id}\")\n    print(f\"MIDI version: {midi.version}\")\n    port = midi.create_port()\n    port.connect_from((0, 1))\n    for event in midi:\n        print(event)\n</code></pre>"},{"location":"api/midi/#linuxpy.midi.device.MidiError","title":"<code>MidiError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>MIDI error</p>"},{"location":"api/midi/#linuxpy.midi.device.Sequencer","title":"<code>Sequencer(name: str = 'linuxpy client', **kwargs)</code>","text":"<p>               Bases: <code>BaseDevice</code></p> <p>Central MIDI class.</p> <pre><code>from linuxpy.midi.device import Sequencer\n\nwith Sequencer(\"My MIDI App\") as midi:\n    print(f\"I'm client {midi.client_id}\")\n    print(f\"MIDI version: {midi.version}\")\n    port = midi.create_port()\n    port.connect_from((0, 1))\n    for event in midi:\n        print(event)\n</code></pre>"},{"location":"api/midi/#linuxpy.midi.device.Sequencer.client_info","title":"<code>client_info: snd_seq_client_info</code>  <code>property</code>","text":"<p>Current Client information</p>"},{"location":"api/midi/#linuxpy.midi.device.Sequencer.client","title":"<code>client: Client</code>  <code>property</code>","text":"<p>Current Client information</p>"},{"location":"api/midi/#linuxpy.midi.device.Sequencer.running_mode","title":"<code>running_mode: snd_seq_running_info</code>  <code>property</code>","text":"<p>Current running mode</p>"},{"location":"api/midi/#linuxpy.midi.device.Sequencer.system_info","title":"<code>system_info: snd_seq_system_info</code>  <code>property</code>","text":"<p>Current system information</p>"},{"location":"api/midi/#linuxpy.midi.device.Sequencer.iter_clients","title":"<code>iter_clients: Iterable[Client]</code>  <code>property</code>","text":"<p>An iterator over all open clients on the system. It returns new Client each time</p>"},{"location":"api/midi/#linuxpy.midi.device.Sequencer.clients","title":"<code>clients: Sequence[Client]</code>  <code>property</code>","text":"<p>Returns a new list of all clients on the system</p>"},{"location":"api/midi/#linuxpy.midi.device.Sequencer.iter_ports","title":"<code>iter_ports: Iterable[Port]</code>  <code>property</code>","text":"<p>An iterator over all open ports on the system. It returns new Port objects each time</p>"},{"location":"api/midi/#linuxpy.midi.device.Sequencer.ports","title":"<code>ports: Sequence[Port]</code>  <code>property</code>","text":"<p>Returns a new list of all open ports on the system. It returns new Port objects each time</p>"},{"location":"api/midi/#linuxpy.midi.device.Sequencer.__iter__","title":"<code>__iter__() -&gt; Iterable[Event]</code>","text":"<p>Build an infinite iterator that streams MIDI events from the subscribed ports. You'll need an open sequencer before using it:</p> <pre><code>from linuxpy.midi.device import Sequencer\n\nwith Sequencer() as midi:\n    port = midi.create_port()\n    port.connect_from((0, 1))\n    for event in midi:\n        print(event)\n</code></pre>"},{"location":"api/midi/#linuxpy.midi.device.Sequencer.__aiter__","title":"<code>__aiter__() -&gt; AsyncIterable[Event]</code>  <code>async</code>","text":"<p>Build an infinite async iterator that streams MIDI events from the subscribed ports. You'll need an open sequencer before using it:</p> <pre><code>import asyncio\nfrom linuxpy.midi.device import Sequencer\n\nasync def main():\n    with Sequencer() as midi:\n        port = midi.create_port()\n        port.connect_from((0, 1))\n        async for event in midi:\n            print(event)\n\nasyncio.run(main())\n</code></pre>"},{"location":"api/midi/#linuxpy.midi.device.Sequencer.get_client","title":"<code>get_client(client_id: int) -&gt; Client</code>","text":"<p>Returns a Client for the given ID or raises an error if the client doesn't exist. It returns new Client object each time</p>"},{"location":"api/midi/#linuxpy.midi.device.Sequencer.get_port","title":"<code>get_port(address: FullPortAddress) -&gt; Port</code>","text":"<p>Returns a Port for the given address or raises an error if the port doesn't exist. It returns new Port object each time</p>"},{"location":"api/midi/#linuxpy.midi.device.Sequencer.create_port","title":"<code>create_port(name: str = 'linuxpy port', capabilities: PortCapability = INPUT_OUTPUT, port_type: PortType = PortType.MIDI_GENERIC | PortType.APPLICATION) -&gt; Port</code>","text":"<p>Create a new local port. By default it will create a MIDI generic application Input/Output port.</p>"},{"location":"api/midi/#linuxpy.midi.device.Sequencer.delete_port","title":"<code>delete_port(port: Union[int, Port])</code>","text":"<p>Delete a previously created local port. If the port has any subscriptions they will be closed before the port is deleted</p>"},{"location":"api/midi/#linuxpy.midi.device.Sequencer.subscribe","title":"<code>subscribe(src: FullPortAddress, dest: FullPortAddress)</code>","text":"<p>Subscribe a source port to a destination port</p>"},{"location":"api/midi/#linuxpy.midi.device.Sequencer.unsubscribe","title":"<code>unsubscribe(src: FullPortAddress, dest: FullPortAddress)</code>","text":"<p>Unsubscribe a previously subscribed source port to a destination port</p>"},{"location":"api/midi/#linuxpy.midi.device.Sequencer.iter_raw_read","title":"<code>iter_raw_read(max_nb_packets: int = 64) -&gt; Iterable[Event]</code>","text":"<p>Read list of pending events. If the sequencer is opened in blocking mode and there are no events it blocks until at least one event occurs otherwise as OSError is raised.</p> <p>Use the <code>read()</code> call instead because it handles blocking vs non-blocking variants transperently.</p>"},{"location":"api/midi/#linuxpy.midi.device.Sequencer.raw_read","title":"<code>raw_read(max_nb_packets=64) -&gt; Sequence[Event]</code>","text":"<p>Read list of pending events. If there are no events it blocks until at least one event occurs and returns it.</p> <p>Use the <code>read()</code> call instead because it handles blocking vs non-blocking variants transperently.</p>"},{"location":"api/midi/#linuxpy.midi.device.Sequencer.wait_read","title":"<code>wait_read() -&gt; Sequence[Event]</code>","text":"<p>Read list of pending events. If there are no events it blocks until at least one event occurs and returns it. This method assumes the internal file descriptior was opened in non-blocking mode.</p> <p>Use the <code>read()</code> call instead because it handles blocking vs non-blocking variants transperently</p>"},{"location":"api/midi/#linuxpy.midi.device.Sequencer.read","title":"<code>read() -&gt; Sequence[Event]</code>","text":"<p>Read list of pending events. If there are no events it blocks until at least one event occurs and returns it</p>"},{"location":"api/midi/#linuxpy.midi.device.Sequencer.write","title":"<code>write(event: Event)</code>","text":"<p>Send an event message</p>"},{"location":"api/midi/#linuxpy.midi.device.Sequencer.send","title":"<code>send(port: PortAddress, event_type: Union[str, int, EventType], queue: int = QUEUE_DIRECT, to: Union[FullPortAddress, FullPortAddresses] = SUBSCRIBERS, **kwargs)</code>","text":"<p>Send a message of the given type from a specific port to the destination address(es). Use kwargs to pass specific event arguments like velocity in a \"note on\" event.</p> <p>event_type can be an instance of EventType or the equivalent number or a case insensitive string matching the event type (ex: \"noteon\", \"NOTEON\", \"note-on\" or \"note on\").</p> <p>The following example sends \"note on\" with velocity 45 on port 0 of client 14:</p> <pre><code>midi.send((14, 0), \"note on\", velocity=45)\n</code></pre>"},{"location":"api/midi/#linuxpy.midi.device.Client","title":"<code>Client(sequencer: Sequencer, client: snd_seq_client_info)</code>","text":"<p>MIDI sequencer client. Don't instantiate this object directly Use instead <code>Sequencer.get_client()</code></p>"},{"location":"api/midi/#linuxpy.midi.device.Client.name","title":"<code>name: str</code>  <code>property</code>","text":"<p>Client name</p>"},{"location":"api/midi/#linuxpy.midi.device.Client.is_local","title":"<code>is_local: bool</code>  <code>property</code>","text":"<p>True if the client was created by the MIDI sequencer that it references or False otherwise\"</p>"},{"location":"api/midi/#linuxpy.midi.device.Client.iter_ports","title":"<code>iter_ports: Iterable[Port]</code>  <code>property</code>","text":"<p>An iterator over all open ports for this client. It returns new Port each time</p>"},{"location":"api/midi/#linuxpy.midi.device.Client.ports","title":"<code>ports: Sequence[Port]</code>  <code>property</code>","text":"<p>Returns a new list of all open ports for this client</p>"},{"location":"api/midi/#linuxpy.midi.device.Client.__int__","title":"<code>__int__()</code>","text":"<p>The client ID</p>"},{"location":"api/midi/#linuxpy.midi.device.Port","title":"<code>Port(sequencer: Sequencer, port: snd_seq_port_info)</code>","text":"<p>MIDI sequencer port. Don't instantiate this object directly Use instead <code>Sequencer.get_port()</code></p>"},{"location":"api/midi/#linuxpy.midi.device.Port.name","title":"<code>name: str</code>  <code>property</code>","text":"<p>Port name</p>"},{"location":"api/midi/#linuxpy.midi.device.Port.is_local","title":"<code>is_local: bool</code>  <code>property</code>","text":"<p>True if the port was created by the MIDI sequencer that it references or False otherwise\"</p>"},{"location":"api/midi/#linuxpy.midi.device.Port.client_id","title":"<code>client_id: int</code>  <code>property</code>","text":"<p>The client ID</p>"},{"location":"api/midi/#linuxpy.midi.device.Port.port_id","title":"<code>port_id: int</code>  <code>property</code>","text":"<p>The port ID</p>"},{"location":"api/midi/#linuxpy.midi.device.Port.type","title":"<code>type: PortType</code>  <code>property</code>","text":"<p>The port type</p>"},{"location":"api/midi/#linuxpy.midi.device.Port.capability","title":"<code>capability: PortCapability</code>  <code>property</code>","text":"<p>The port capabilities</p>"},{"location":"api/midi/#linuxpy.midi.device.Port.address","title":"<code>address: snd_seq_addr</code>  <code>property</code>","text":"<p>The port address</p>"},{"location":"api/midi/#linuxpy.midi.device.Port.__int__","title":"<code>__int__()</code>","text":"<p>The port ID</p>"},{"location":"api/midi/#linuxpy.midi.device.Port.connect_from","title":"<code>connect_from(src: FullPortAddress)</code>","text":"<p>Connect this port to a remote port. After connecting, this port will receive events originating from the source port.</p> <p>Example:</p> <pre><code>from linuxpy.midi.device import Sequencer\n\nwith Sequencer() as midi:\n    port = midi.create_port()\n    port.connect_from((0, 1))\n    for event in midi:\n        print(event)\n</code></pre>"},{"location":"api/midi/#linuxpy.midi.device.Port.disconnect_from","title":"<code>disconnect_from(src: FullPortAddress)</code>","text":"<p>Disconnect this port from a previously connected source port.</p>"},{"location":"api/midi/#linuxpy.midi.device.Port.connect_to","title":"<code>connect_to(dest: FullPortAddress)</code>","text":"<p>Connect this port to a remote port. After connecting, events originating from this port will be sent to the destination port.</p> <p>Example:</p> <pre><code>from linuxpy.midi.device import Sequencer\n\nwith Sequencer() as midi:\n    port = midi.create_port()\n    # Assume 14:0 is Midi Through\n    port.connect_to((14, 0))\n    port.send(\"note on\", note=11, velocity=10)\n</code></pre>"},{"location":"api/midi/#linuxpy.midi.device.Port.disconnect_to","title":"<code>disconnect_to(dest: FullPortAddress)</code>","text":"<p>Disconnect this port from a previously connected destination port.</p>"},{"location":"api/midi/#linuxpy.midi.device.Port.delete","title":"<code>delete()</code>","text":"<p>Delete this port. Raises MidiError if port is not local. Any subscriptions are canceled before the port is deleted.</p>"},{"location":"api/midi/#linuxpy.midi.device.Port.send","title":"<code>send(event_type: Union[str, int, EventType], **kwargs)</code>","text":"<p>Send a message of the given type from to the destination address(es). Use kwargs to pass specific event arguments like velocity in a \"note on\" event.</p> <p>event_type can be an instance of EventType or the equivalent number or a case insensitive string matching the event type (ex: \"noteon\", \"NOTEON\", \"note-on\" or \"note on\").</p> <p>The following example sends \"note on\" on note 42, with velocity 45:</p> <pre><code>port.send(\"note on\", note=42, velocity=45)\n</code></pre>"},{"location":"api/midi/#linuxpy.midi.device.Event","title":"<code>Event(event: snd_seq_event)</code>","text":"<p>Event message object result of listening on a sequencer</p>"},{"location":"api/midi/#linuxpy.midi.device.Event.__bytes__","title":"<code>__bytes__()</code>","text":"<p>Serialize the Event in a bytes ready to be sent</p>"},{"location":"api/midi/#linuxpy.midi.device.Event.new","title":"<code>new(etype: EventT, **kwargs)</code>  <code>classmethod</code>","text":"<p>Create new Event of the given type</p>"},{"location":"api/midi/#linuxpy.midi.device.to_address","title":"<code>to_address(addr: FullPortAddress) -&gt; snd_seq_addr</code>","text":"<p>Convert to low level snd_seq_addr</p>"},{"location":"api/midi/#linuxpy.midi.device.event_stream","title":"<code>event_stream(sequencer: Sequencer) -&gt; Iterable[Event]</code>","text":"<p>Infinite stream of events coming from the given sequencer</p>"},{"location":"api/midi/#linuxpy.midi.device.async_event_stream","title":"<code>async_event_stream(sequencer: Sequencer, maxsize: int = 10) -&gt; AsyncIterable[Event]</code>  <code>async</code>","text":"<p>Infinite async stream of events coming from the given sequencer</p>"},{"location":"api/thermal/","title":"\ud83c\udf21\ufe0f Thermal and cooling API","text":""},{"location":"api/thermal/#linuxpy.thermal","title":"<code>linuxpy.thermal</code>","text":"<p>Human friendly interface to linux thermal subsystem.</p> <p>The heart of linuxpy thermal library are the <code>ThermalZone</code> and <code>CoolingDevice</code> classes.</p> <p>Probably the most common way to create a thermal device is through the <code>find</code> helper:</p> <pre><code>with find(type=\"x86_pkg_temp\") as tz:\n    print(f\"X86 temperature: {tz.temperature/1000:6.2f} C\")\n</code></pre>"},{"location":"api/thermal/#linuxpy.thermal.ThermalZone","title":"<code>ThermalZone(syspath: os.PathLike)</code>","text":"<p>               Bases: <code>Device</code></p> <p>Thermal sensor</p> ATTRIBUTE DESCRIPTION <code>type</code> <p>thermal zone type</p> <p> TYPE: <code>str</code> </p> <code>policy</code> <p>the policy</p> <p> TYPE: <code>str</code> </p> <code>available_policies</code> <p>list of available policies</p> <p> TYPE: <code>list[str]</code> </p> <code>temperature</code> <p>current temperature in milli-celsius</p> <p> TYPE: <code>int</code> </p> <code>offset</code> <p>offet in milli-celsius</p> <p> TYPE: <code>int</code> </p> <code>mode</code> <p>current mode (enabled/disabled)</p> <p> TYPE: <code>Mode</code> </p> <code>device_number</code> <p>thermal device number</p> <p> TYPE: <code>int</code> </p> <code>trip_points</code> <p>list of trip points (new list every time)</p> <p> TYPE: <code>list[TripPoint]</code> </p>"},{"location":"api/thermal/#linuxpy.thermal.TripPoint","title":"<code>TripPoint(temperature_path, type_path)</code>","text":"<p>Trip point associated with the thermal zone</p> ATTRIBUTE DESCRIPTION <code>temperature</code> <p>trip point temperature in milli-celsius</p> <p> TYPE: <code>int</code> </p> <code>type</code> <p>trip point type</p> <p> TYPE: <code>str</code> </p>"},{"location":"api/thermal/#linuxpy.thermal.CoolingDevice","title":"<code>CoolingDevice(syspath: os.PathLike)</code>","text":"<p>               Bases: <code>Device</code></p> <p>Cooling device (fan, processor, ...)</p> ATTRIBUTE DESCRIPTION <code>type</code> <p>thermal zone type</p> <p> TYPE: <code>str</code> </p>"},{"location":"api/thermal/#linuxpy.thermal.iter_thermal_zone_paths","title":"<code>iter_thermal_zone_paths() -&gt; Iterable[pathlib.Path]</code>","text":"<p>Returns an iterator over all thermal zone paths</p>"},{"location":"api/thermal/#linuxpy.thermal.iter_thermal_zone_devices","title":"<code>iter_thermal_zone_devices() -&gt; Iterable[ThermalZone]</code>","text":"<p>Returns an iterator over all thermal zone devices</p>"},{"location":"api/thermal/#linuxpy.thermal.iter_cooling_device_paths","title":"<code>iter_cooling_device_paths() -&gt; Iterable[pathlib.Path]</code>","text":"<p>Returns an iterator over all cooling device paths</p>"},{"location":"api/thermal/#linuxpy.thermal.iter_cooling_devices","title":"<code>iter_cooling_devices() -&gt; Iterable[CoolingDevice]</code>","text":"<p>Returns an iterator over all cooling devices</p>"},{"location":"api/thermal/#linuxpy.thermal.iter_devices","title":"<code>iter_devices() -&gt; Iterable[Union[ThermalZone, CoolingDevice]]</code>","text":"<p>Returns an iterator over all thermal and cooling devices</p>"},{"location":"api/thermal/#linuxpy.thermal.find","title":"<code>find(find_all: bool = False, custom_match: Optional[Callable] = None, **kwargs) -&gt; Union[Device, Iterable[Device], None]</code>","text":"<p>If find_all is False:</p> <p>Find a device follwing the criteria matched by custom_match and kwargs. If no device is found matching the criteria it returns None. Default is to return a random first device.</p> <p>If find_all is True:</p> <p>The result is an iterator. Find all devices that match the criteria custom_match and kwargs. If no device is found matching the criteria it returns an empty iterator. Default is to return an iterator over all input devices found on the system.</p>"},{"location":"api/types/","title":"Typing","text":""},{"location":"api/types/#linuxpy.types","title":"<code>linuxpy.types</code>","text":""},{"location":"api/util/","title":"Utilities","text":""},{"location":"api/util/#linuxpy.util","title":"<code>linuxpy.util</code>","text":"<p>Utility functions used by the library. Mostly for internal usage</p>"},{"location":"api/util/#linuxpy.util.aclosing","title":"<code>aclosing(thing)</code>","text":"<p>               Bases: <code>AbstractAsyncContextManager</code></p> <p>Async context manager for safely finalizing an asynchronously cleaned-up resource such as an async generator, calling its <code>aclose()</code> method.</p> <p>This is a copy of contextlib.aclosing needed for python 3.9 compatibility</p>"},{"location":"api/util/#linuxpy.util.Version","title":"<code>Version(major: int, minor: int, patch: int)</code>","text":"<p>Simple version supporting only a.b.c format</p>"},{"location":"api/util/#linuxpy.util.Version.tuple","title":"<code>tuple</code>  <code>property</code>","text":"<p>Returns a 3 element tuple representing the version so <code>Version(3,2,1).tuple()</code> yields the tuple <code>(3, 2, 1)</code></p>"},{"location":"api/util/#linuxpy.util.Version.from_tuple","title":"<code>from_tuple(sequence: Iterable[Union[str, int]])</code>  <code>classmethod</code>","text":"<p>Create a Version from any sequence/iterable of 3 elements</p> <p>Examples that create a Version \"3.2.1\" object: <pre><code>Version.from_tuple([3, 2, 1])\nVersion.from_tuple([\"3\", 2, \"1\"])\nVersion.from_tuple(range(3, 0, -1))\n\n# This will work although not recommended since it will not work\n# when any of the members is bigger than 9\nVersion.from_tuple(\"321\")\n</code></pre></p>"},{"location":"api/util/#linuxpy.util.Version.from_str","title":"<code>from_str(text)</code>  <code>classmethod</code>","text":"<p>Create a Version from text</p> <p>Example that create a Version \"3.2.1\" object: <pre><code>Version.from_str(\"3.2.1\")\n</code></pre></p>"},{"location":"api/util/#linuxpy.util.Version.from_number","title":"<code>from_number(number: int)</code>  <code>classmethod</code>","text":"<p>Create a Version from an integer where each member corresponds to one byte in the integer so that 0xFFFEFD corresponds to 255.254.253</p> <p>Example that create a Version \"3.2.1\" object: <pre><code>Version.from_number((3&lt;&lt;16) + (2&lt;&lt;8) + 1)\n</code></pre></p>"},{"location":"api/util/#linuxpy.util.iter_chunks","title":"<code>iter_chunks(lst: Sequence, size: int) -&gt; Iterable</code>","text":"<p>Batch data from the sequence into groups of length n. The last batch may be shorter than size.</p>"},{"location":"api/util/#linuxpy.util.chunks","title":"<code>chunks(lst: Sequence, size: int) -&gt; tuple</code>","text":"<p>Batch data from the sequence into groups of length n. The last batch may be shorter than size.</p>"},{"location":"api/util/#linuxpy.util.bcd_version_tuple","title":"<code>bcd_version_tuple(bcd: int) -&gt; tuple[int, ...]</code>","text":"<p>Returns the tuple version of a BCD (binary-coded decimal) number</p>"},{"location":"api/util/#linuxpy.util.bcd_version","title":"<code>bcd_version(bcd: int) -&gt; str</code>","text":"<p>Returns the text version of a BCD (binary-coded decimal) number</p>"},{"location":"api/util/#linuxpy.util.to_fd","title":"<code>to_fd(fd: FDLike)</code>","text":"<p>Return a file descriptor from a file object.</p> <p>Parameters: fd -- file object or file descriptor</p> <p>Returns: corresponding file descriptor</p> <p>Raises: ValueError if the object is invalid</p>"},{"location":"api/util/#linuxpy.util.try_numeric","title":"<code>try_numeric(text: str, order=(int, int16, float))</code>","text":"<p>Try to translate given text into int, int base 16 or float. Returns the orig and return the original text if it fails.</p> PARAMETER DESCRIPTION <code>text</code> <p>text to be translated</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <p>int, float or str: The converted text</p>"},{"location":"api/util/#linuxpy.util.add_reader_asyncio","title":"<code>add_reader_asyncio(fd: FDLike, callback: Callable, *args, loop: Optional[asyncio.AbstractEventLoop] = None)</code>","text":"<p>Add reader during the context and remove it after</p>"},{"location":"api/util/#linuxpy.util.Selector","title":"<code>Selector(fds: Collection[FDLike], events=selectors.EVENT_READ) -&gt; selectors.DefaultSelector</code>","text":"<p>A selectors.DefaultSelector with given fds registered</p>"},{"location":"api/util/#linuxpy.util.selector_stream","title":"<code>selector_stream(selector: selectors.BaseSelector, timeout: Optional[float] = None) -&gt; Iterable[SelectorEvent]</code>","text":"<p>A stream of selector read events</p>"},{"location":"api/util/#linuxpy.util.selector_file_stream","title":"<code>selector_file_stream(fds: Collection[FDLike], timeout: Optional[float] = None) -&gt; Iterable[SelectorEvent]</code>","text":"<p>An inifinte stream of selector read events</p>"},{"location":"api/util/#linuxpy.util.file_stream","title":"<code>file_stream(fds: Collection[FDLike], timeout: Optional[float] = None) -&gt; Iterable[FDLike]</code>","text":"<p>An infinite stream of read ready file descriptors</p>"},{"location":"api/util/#linuxpy.util.event_stream","title":"<code>event_stream(fds: Collection[FDLike], read: Callable[[FDLike], T], timeout: Optional[float] = None) -&gt; Iterable[T]</code>","text":"<p>An infinite stream of events. The given read callable is called for each file that is reported as ready</p>"},{"location":"api/util/#linuxpy.util.async_selector_stream","title":"<code>async_selector_stream(selector: selectors.BaseSelector) -&gt; AsyncIterator[SelectorEvent]</code>  <code>async</code>","text":"<p>An asyncronous infinite stream of selector read events</p>"},{"location":"api/util/#linuxpy.util.async_selector_file_stream","title":"<code>async_selector_file_stream(fds: Collection[FDLike]) -&gt; AsyncIterator[SelectorEvent]</code>  <code>async</code>","text":"<p>An asyncronous infinite stream of selector read events</p>"},{"location":"api/util/#linuxpy.util.async_file_stream","title":"<code>async_file_stream(fds: Collection[FDLike]) -&gt; AsyncIterator[FDLike]</code>  <code>async</code>","text":"<p>An asyncronous infinite stream of read ready files</p>"},{"location":"api/util/#linuxpy.util.async_event_stream","title":"<code>async_event_stream(fds: Collection[FDLike], read: Callable[[FDLike], T])</code>  <code>async</code>","text":"<p>An asyncronous stream of events. The given read callable is called for each file that is reported as ready</p>"},{"location":"api/util/#linuxpy.util.make_find","title":"<code>make_find(iter_devices: Callable[[], Iterator], needs_open=True) -&gt; Callable</code>","text":"<p>Create a find function for the given callable. The callable should return an iterable where each element has the context manager capability (ie, it can be used in a with statement)</p>"},{"location":"api/util/#linuxpy.util.bit_indexes","title":"<code>bit_indexes(number: int) -&gt; list[int]</code>","text":"<p>Return the list of indexes that have an active bit on the number.</p> <p>Example bit_indexes(74) gives [1, 3, 6] (74 == 0b1001010)</p>"},{"location":"api/util/#linuxpy.util.sequence_indexes","title":"<code>sequence_indexes(it: Iterable[T]) -&gt; dict[T, int]</code>","text":"<p>Return a map with key being the value in the given iterable and value the index where it appears in the map. If the same element appears more than once then the last occurence is returned. Elements must be non mutable so they can appear in the returned map Example:</p> <p><code>sequence_indexes([10, \"bla\", 1]) == {10: 0, \"bla\": 1, 1: 2}</code></p> PARAMETER DESCRIPTION <code>lines</code> <p>The iterable to be returned</p> <p> TYPE: <code>Iterable[int]</code> </p> RETURNS DESCRIPTION <code>dict[T, int]</code> <p>dict[int, int]: map of values and their indexes</p>"},{"location":"api/util/#linuxpy.util.index_mask","title":"<code>index_mask(indexes: dict[T, int], elements: Iterable[T]) -&gt; int</code>","text":"<p>Return a bit mask with active bits from elements. The bit index for each element is given by the indexes</p> PARAMETER DESCRIPTION <code>indexes</code> <p>bit index map</p> <p> TYPE: <code>dict[T, int]</code> </p> <code>elements</code> <p>list of active elements</p> <p> TYPE: <code>Iterable[T]</code> </p> RETURNS DESCRIPTION <code>int</code> <p>bit mask</p> <p> TYPE: <code>int</code> </p>"},{"location":"api/util/#linuxpy.util.random_name","title":"<code>random_name(min_length=32, max_length=32)</code>","text":"<p>Generates a random name like text of ascii characters (letters or digits).</p> <p>The first character is always a letter</p>"},{"location":"api/video/","title":"\ud83c\udfa5 Video API","text":""},{"location":"api/video/#linuxpy.video.device","title":"<code>linuxpy.video.device</code>","text":"<p>Human friendly interface to V4L2 (Video 4 Linux 2) subsystem.</p>"},{"location":"api/video/#linuxpy.video.device.V4L2Error","title":"<code>V4L2Error</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Video for linux 2 error</p>"},{"location":"api/video/#linuxpy.video.device.Controls","title":"<code>Controls(device: Device)</code>","text":"<p>               Bases: <code>dict</code></p>"},{"location":"api/video/#linuxpy.video.device.Controls.from_device","title":"<code>from_device(device)</code>  <code>classmethod</code>","text":""},{"location":"api/video/#linuxpy.video.device.InfoEx","title":"<code>InfoEx(device: Device)</code>","text":"<p>               Bases: <code>DeviceHelper</code></p>"},{"location":"api/video/#linuxpy.video.device.InfoEx.video_standards","title":"<code>video_standards: list[Standard]</code>  <code>property</code>","text":"<p>List of video standards for the active input</p>"},{"location":"api/video/#linuxpy.video.device.Frame","title":"<code>Frame(data: bytes, buff: raw.v4l2_buffer, format: Format)</code>","text":"<p>The resulting object from an acquisition.</p>"},{"location":"api/video/#linuxpy.video.device.EventReader","title":"<code>EventReader(device: Device, max_queue_size=100)</code>","text":""},{"location":"api/video/#linuxpy.video.device.EventReader.aread","title":"<code>aread()</code>  <code>async</code>","text":"<p>Wait for next event or return last event in queue</p>"},{"location":"api/video/#linuxpy.video.device.FrameReader","title":"<code>FrameReader(device: Device, raw_read: Callable[[], Buffer], max_queue_size: int = 1)</code>","text":""},{"location":"api/video/#linuxpy.video.device.FrameReader.aread","title":"<code>aread() -&gt; Frame</code>  <code>async</code>","text":"<p>Wait for next frame or return last frame</p>"},{"location":"api/video/#linuxpy.video.device.create_buffers","title":"<code>create_buffers(fd, format: raw.v4l2_format, memory: Memory, count: int) -&gt; raw.v4l2_create_buffers</code>","text":"<p>Create buffers for Memory Mapped or User Pointer or DMA Buffer I/O</p>"},{"location":"api/video/#linuxpy.video.device.convert_to_ctypes_array","title":"<code>convert_to_ctypes_array(lst, depth, ctype)</code>","text":"<p>Convert a list (arbitrary depth) to a ctypes array.</p>"},{"location":"api/video/#linuxpy.video.device.request_and_query_buffer","title":"<code>request_and_query_buffer(fd, buffer_type: BufferType, memory: Memory) -&gt; raw.v4l2_buffer</code>","text":"<p>request + query buffers</p>"},{"location":"api/video/#linuxpy.video.device.request_and_query_buffers","title":"<code>request_and_query_buffers(fd, buffer_type: BufferType, memory: Memory, count: int) -&gt; list[raw.v4l2_buffer]</code>","text":"<p>request + query buffers</p>"},{"location":"api/video/#linuxpy.video.device.create_mmap_buffers","title":"<code>create_mmap_buffers(fd, buffer_type: BufferType, memory: Memory, count: int) -&gt; list[mmap.mmap]</code>","text":"<p>create buffers + mmap_from_buffer</p>"},{"location":"api/video/#linuxpy.video.device.iter_video_files","title":"<code>iter_video_files(path: PathLike = '/dev') -&gt; Iterable[Path]</code>","text":"<p>Returns an iterator over all video files</p>"},{"location":"api/video/#linuxpy.video.device.iter_devices","title":"<code>iter_devices(path: PathLike = '/dev', **kwargs) -&gt; Iterable[Device]</code>","text":"<p>Returns an iterator over all video devices</p>"},{"location":"api/video/#linuxpy.video.device.iter_video_capture_files","title":"<code>iter_video_capture_files(path: PathLike = '/dev') -&gt; Iterable[Path]</code>","text":"<p>Returns an iterator over all video files that have CAPTURE capability</p>"},{"location":"api/video/#linuxpy.video.device.iter_video_capture_devices","title":"<code>iter_video_capture_devices(path: PathLike = '/dev', **kwargs) -&gt; Iterable[Device]</code>","text":"<p>Returns an iterator over all video devices that have CAPTURE capability</p>"},{"location":"api/video/#linuxpy.video.device.iter_video_output_files","title":"<code>iter_video_output_files(path: PathLike = '/dev') -&gt; Iterable[Path]</code>","text":"<p>Some drivers (ex: v4l2loopback) don't report being output capable so that apps like zoom recognize them as valid capture devices so some results might be missing</p>"},{"location":"api/video/#linuxpy.video.device.iter_video_output_devices","title":"<code>iter_video_output_devices(path: PathLike = '/dev', **kwargs) -&gt; Iterable[Device]</code>","text":"<p>Returns an iterator over all video devices that have VIDEO OUTPUT capability</p>"},{"location":"user_guide/","title":"User guide","text":"<p>This tutorial shows you how to use LinuxPy with most of its features.</p> GREETINGS PROFESSOR FALKEN. SHALL WE PLAY A GAME? Love to. How about Global Thermonuclear War? WOULDN'T YOU PREFER A GOOD GAME OF CHESS? Later. Let's play Global Thermonuclear War. FINE."},{"location":"user_guide/gpio/","title":"\u26a1 GPIO","text":"<p>Human friendly interface to linux GPIO handling.</p> <p>Without further ado:</p> python from linuxpy.gpio import find with find() as gpio:     with gpio.request([1, 2, 8]) as lines:         print(lines[:]) {1: 0, 2: 1, 8:0}"},{"location":"user_guide/gpio/#basics","title":"Basics","text":"<p>The GPIO interface consists of a Device class representing a single gpiochip.</p> <p>The Device works as a context manager but you can also manually handle open/close.</p> <p>Example:</p> <pre><code>from linuxpy.gpio import Device\n\nwith Device.from_id(0) as gpio:\n    info = gpio.get_info()\n    print(info.name, info.label, len(info.lines))\n    l0 = info.lines[0]\n    print(f\"L0: {l0.name!r} {l0.flags.name}\")\n\n# output should look somethig like:\n# gpiochip0 INT3450:00 32\n# L0: '' INPUT\n</code></pre> <p>The example above also shows how to obtain information about the gpio device including up to date information about line usage.</p> <p>linuxpy provides a <code>find</code> helper that makes it easier on single chip systems to work without knowing the chip number. So the example above can be written using <code>find</code>:</p> <pre><code>from linuxpy.gpio import find\n\nwith find() as gpio:\n    info = gpio.get_info()\n    print(info.name, info.label, len(info.lines))\n    l0 = info.lines[0]\n    print(f\"L0: {l0.name!r} {l0.flags.name}\")\n</code></pre>"},{"location":"user_guide/gpio/#working-with-lines-request","title":"Working with lines: Request","text":"<p>Lines need to be requested before working with them. A request for line(s) reserves it at the OS level for exclusive access by the requestor.</p> <p>The API uses a context manager and it looks like this:</p> <pre><code>with find() as gpio:\n    with gpio.request([5, 12]) as lines:\n        ...\n</code></pre> <p>The request is only sent to the OS at the entry of the context manager.</p> <p>The above example uses lines 5 and 12 in INPUT mode which is the default.</p> <p>Linuxpy transparently handles requests with more than 64 lines.</p> <p>The request argument is intented to supports all possible configurations needed. It can have different forms:</p>"},{"location":"user_guide/gpio/#line-number","title":"line number","text":"<p>A single line is reserved with the default configuration (see below for defaults).</p> <p>Example:</p> <pre><code>with find() as gpio:\n    with gpio.request(5) as lines:\n        ...\n</code></pre>"},{"location":"user_guide/gpio/#list-of-line-numbers-or-line-configurations","title":"list of line numbers or line configurations","text":"<p>Example:</p> <pre><code>with find() as gpio:\n    with gpio.request([5, {\"line\": 6, \"direction\": \"output\"}) as lines:\n        ...\n</code></pre> <p>Reserves line 5 with default configuration and line 6 as output.</p>"},{"location":"user_guide/gpio/#dictionary","title":"dictionary","text":"<p>With keys:</p> <ul> <li>name: the reservation name</li> <li>lines: the lines to be reserved. Can be<ul> <li>a line number</li> <li>list of line numbers or line configs</li> <li>a dict where key is line number and value a line config with \"line\" ommited</li> </ul> </li> </ul> <p>Example:</p> <pre><code>config = {\n    \"name\": \"myself\",\n    \"lines\": [5, {\"line\": 6, \"direction\": \"output\"}],\n}\n\n# the same above with line config map:\n\nconfig = {\n    \"name\": \"myself\",\n    \"lines\": {\n        5: {},\n        6: {\"direction\": \"output\"},\n    }\n}\n\nwith find() as gpio:\n    with gpio.request(config) as lines:\n        ...\n</code></pre>"},{"location":"user_guide/gpio/#helpers","title":"helpers","text":"<p>A line configuration helper is provided:</p> <pre><code>CLine(nb, direction, bias, drive, edge, clock, debounce) -&gt; dict\n</code></pre> <p>Example: <pre><code>from linuxpy.gpio.device import CLine\n\nconfig = {\n    \"name\": \"myself\",\n    \"lines\": [CLine(5), CLine(6, \"output\")]\n}\n\nwith find() as gpio:\n    with gpio.request(config) as lines:\n        ...\n</code></pre></p> <p>Selecting input / output lines is a common pattern. Linuxpy provides</p> <ul> <li><code>ClineIn(n, **options)</code> &lt;=&gt; <code>{\"line\":n, \"direction\": \"input\", **options)</code></li> <li><code>ClineOut(n, **options)</code> &lt;=&gt; <code>{\"line\":n, \"direction\": \"output\", **options)</code></li> </ul>"},{"location":"user_guide/gpio/#line-details","title":"Line details","text":"<p>Here are the line configuration options with their restrictions and defaults:</p> <ul> <li>direction:<ul> <li>possible values: <code>input</code>, <code>output</code></li> <li>default: input</li> </ul> </li> <li>active:<ul> <li>possible values: <code>high</code>, <code>low</code></li> <li>default: high</li> </ul> </li> <li>bias:<ul> <li>possbile values: <code>pull-up</code>, <code>pull-down</code>, <code>none</code></li> <li>default: none</li> </ul> </li> <li>clock:<ul> <li>possbile values: <code>realtime</code>, <code>hte</code>, <code>monotonic</code></li> <li>default: monotonic</li> </ul> </li> <li>edge:<ul> <li>possbile values: <code>rising</code>, <code>falling</code>, <code>both</code>, <code>none</code></li> <li>default: none</li> <li>restrictions: only valid for INPUT lines</li> </ul> </li> <li>drive:<ul> <li>possbile values: <code>drain</code>, <code>source</code>, <code>push-pull</code>.</li> <li>default: push-pull</li> <li>restrictions: only valid for OUTPUT lines</li> </ul> </li> <li>debounce:<ul> <li>possible values: number (int or float) &gt; 0. Debounce in seconds with micro-second precision</li> <li>default: use the current debouce</li> <li>restrictions: only valid for OUTPUT lines</li> </ul> </li> </ul>"},{"location":"user_guide/gpio/#writting","title":"Writting","text":"<p>In the following examples we will use the <code>CLineOut</code> helper which is short for <code>CLine(direction=\"output\")</code>.</p> <p>To change OUTPUT line(s) value(s) simply invoke the <code>set_values</code> method on the request object:</p> <pre><code>with find() as gpio:\n    with device.request([CLineOut(5), CLineOut(7)]) as lines:\n        lines.set_values({5: 1})\n</code></pre> <p>The example above reserves lines 5 and 7 for output by a client (aka consumer) called my sweet app. It then sets line 5 to 1. As you can see, it is possible to write only the lines you're interested.</p> <p>A helper is provided for 'dict like' access. So the example above can also be written as:</p> <pre><code>with find() as gpio:\n    with device.request([CLineOut(5), CLineOut(7)]) as lines:\n        lines[5] = 1\n</code></pre> <p>The dict like API also supports setting multiple lines.</p> <p>Here are some examples using the CLineOut helper:</p> <pre><code>with find() as gpio:\n    with device.request([CLineOut(i) for i in range(16)]) as lines:\n        # write line 5\n        lines[5] = 1\n        # set lines 7, 5, to 0 and 1 respectively\n        lines[7, 5] = 0, 1\n        # set all lines to 0\n        lines[:] = 0\n        # set lines 3, 10 to 0 and lines 12 to 1, 13 to 0 and 14 to 1\n        lines[3, 10, 12:15] = (0, 0, 1, 0, 1)\n</code></pre>"},{"location":"user_guide/gpio/#reading","title":"Reading","text":"<p>Reading line values is very similar to writting:</p> <pre><code>with find() as gpio:\n    with device.request([CLineIn(6), CLineIn(12]) as lines:\n        values = lines.get_values([6, 12])\n\n        # values will be something like {6: 0, 12: 1}\n</code></pre> <p>In the above example with</p> <p>The \"dict like\" API is also supported for reading so the above example could be written as:</p> <pre><code>with find() as gpio:\n    with device.request([CLineIn(6), CLineIn(12]) as lines:\n        values = lines[6, 12]\n</code></pre> <p>A more complex reads also works:</p> <pre><code>with find() as gpio:\n    with device.request([CLineIn(i) for i in range(16)]) as lines:\n        # read lines 7, 5\n        values = lines[7, 5]\n        # read all lines\n        values = lines[:]\n        # read lines 3, 6, 10, 12, 14\n        values = lines[3, 6, 10:16:2]\n</code></pre>"},{"location":"user_guide/gpio/#edge-detection-events","title":"Edge detection events","text":"<p>The request object can be used as an infinite iterator to watch for line events:</p> <pre><code>with find() as gpio:\n    with device.request([1, 4]) as lines:\n        for event in lines:\n            print(f\"{event.type.name} #{event.sequence} detected for line {event.line}\")\n</code></pre> <p>Reading one event is easy:</p> <pre><code>event = next(iter(lines))\n</code></pre>"},{"location":"user_guide/gpio/#asyncio","title":"asyncio","text":"<p>Async API is also supported:</p> <pre><code>import asyncio\n\n\nasync def main():\n    with find() as gpio:\n        with device.request([1, 4]) as lines:\n            async for event in lines:\n                print(f\"{event.type.name} #{event.sequence} detected for line {event.line}\")\n\n\nasyncio.run(main())\n</code></pre>"},{"location":"user_guide/gpio/#configuration-events","title":"Configuration events","text":"<p>Linuxpy GPIO API supports watching for line configuration events:</p> <pre><code>with find() as gpio:\n    for event in gpio.info_stream([5, 10]):\n        print(event)\n</code></pre> <p>The example above will listen for configuration change, line request and line released events on lines 5 and 10.</p> <p>If you need fine control you can manually register for line watch and then listen for events. So the above example can also be written as:</p> <pre><code>with find() as gpio:\n    with gpio.watching([5, 10]):\n        for event in gpio:\n            print(event)\n</code></pre> <p>Or even:</p> <pre><code>with find() as gpio:\n    gpio.watch_lines([5, 10])\n    try:\n        for event in gpio:\n            print(event)\n    finally:\n        gpio.unwatch_lines([5, 10])\n</code></pre>"},{"location":"user_guide/gpio/#asyncio_1","title":"asyncio","text":"<p>Async API is also supported on configuration events:</p> <pre><code>import asyncio\nimport contextlib\n\n\nasync def main():\n    with find() as gpio:\n        async with contextlib.aclosing(gpio.async_info_stream([5, 10])) as stream:\n            async for event in stream:\n                print(event)\n\n\nasyncio.run(main())\n</code></pre>"},{"location":"user_guide/input/","title":"\ud83d\udd79\ufe0f Input","text":"<p>Human friendly interface to the Linux Input subsystem.</p> <ul> <li>\ud83c\udfae Gamepads</li> <li>\ud83d\udd79\ufe0f Joysticks</li> <li>\ud83d\uddb1\ufe0f Mice</li> <li>\u2328\ufe0f Keyboards</li> <li>\ud83d\udd18 Switch buttons</li> </ul> <p>API not documented yet. Just this example:</p> <pre><code>import time\nfrom linuxpy.input.device import find_gamepads\n\npad = next(find_gamepads())\nabs = pad.absolute\n\nwith pad:\n    while True:\n        print(f\"X:{abs.x:&gt;3} | Y:{abs.y:&gt;3} | RX:{abs.rx:&gt;3} | RY:{abs.ry:&gt;3}\", end=\"\\r\", flush=True)\n        time.sleep(0.1)\n</code></pre>"},{"location":"user_guide/input/#asyncio","title":"asyncio","text":"python -m asyncio from linuxpy.input.device import find_gamepad with find_gamepad() as pad:     async for event in pad:         print(event) InputEvent(time=1697520475.348099, type=&lt;EventType.SYN: 0&gt;, code=&lt;Synchronization.REPORT: 0&gt;, value=0) InputEvent(time=1697520475.361564, type=&lt;EventType.REL: 2&gt;, code=&lt;Relative.X: 0&gt;, value=-1) InputEvent(time=1697520475.361564, type=&lt;EventType.REL: 2&gt;, code=&lt;Relative.Y: 1&gt;, value=1) InputEvent(time=1697520475.361564, type=&lt;EventType.SYN: 0&gt;, code=&lt;Synchronization.REPORT: 0&gt;, value=0) InputEvent(time=1697520475.371128, type=&lt;EventType.REL: 2&gt;, code=&lt;Relative.X: 0&gt;, value=-1) InputEvent(time=1697520475.371128, type=&lt;EventType.SYN: 0&gt;, code=&lt;Synchronization.REPORT: 0&gt;, value=0) ..."},{"location":"user_guide/input/#references","title":"References","text":"<ul> <li>Input (Latest)</li> <li>Input 6.2</li> </ul>"},{"location":"user_guide/input/#_1","title":"\ud83d\udc27","text":""},{"location":"user_guide/led/","title":"\ud83d\udca1 Led","text":"<p>Human friendly interface to linux led handling.</p> <p>Without further ado:</p> python from linuxpy.led import find caps_lock = find(function=\"capslock\") print(caps_lock.max_brightness) 1 print(caps_lock.brightness) 0 caps_lock.brightness = 1 print(caps_lock.brightness) 1"},{"location":"user_guide/midi/","title":"\ud83c\udfb9  MIDI Sequencer","text":"<p>Without further ado:</p> python from linuxpy.midi.device import Sequencer with Sequencer() as seq:     port = seq.create_port()     port.connect_from(14, 0)     for event in seq:         print(event)  14:0   Note on              channel=0, note=100, velocity=3, off_velocity=0, duration=0  14:0   Clock                queue=0, pad=b''  14:0   System exclusive     F0 61 62 63 F7  14:0   Note off             channel=0, note=55, velocity=3, off_velocity=0, duration=0"},{"location":"user_guide/midi/#system-information","title":"System information","text":"<pre><code>$ python\n&gt;&gt;&gt; from linuxpy.midi.device import Sequencer\n&gt;&gt;&gt; seq = Sequencer(\"a midi client\")\n&gt;&gt;&gt; seq.open()\n\n&gt;&gt;&gt; seq.version\n1.0.2\n\n&gt;&gt;&gt; seq.client_info\nsnd_seq_client_info(client=128, type=1, name=b'a midi client', filter=0, multicast_filter=b'', event_filter=b'', num_ports=0, event_lost=0, card=-1, pid=1288570)\n\n&gt;&gt;&gt; seq.running_mode\nsnd_seq_running_info(client=0, big_endian=0, cpu_mode=0, pad=0)\n\n&gt;&gt;&gt; seq.system_info\nsnd_seq_system_info(queues=32, clients=192, ports=254, channels=256, cur_clients=3, cur_queues=0)\n</code></pre>"},{"location":"user_guide/midi/#asyncio","title":"asyncio","text":"<p>asyncio is a first class citizen to linuxpy.midi:</p> <pre><code>$ python -m asyncio\n\n&gt;&gt;&gt; from linuxpy.midi.device import Sequencer\n&gt;&gt;&gt; with Sequencer() as seq:\n...     port = seq.create_port()\n...     port.connect_from(14, 0)\n...     async for event in seq:\n...         print(event)\n 14:0   Note on              channel=0, note=100, velocity=3, off_velocity=0, duration=0\n 14:0   Clock                queue=0, pad=b''\n 14:0   System exclusive     F0 61 62 63 F7\n 14:0   Note off             channel=0, note=55, velocity=3, off_velocity=0, duration=0\n</code></pre>"},{"location":"user_guide/midi/#cli","title":"CLI","text":"<p>A basic CLI is provided that allows listing MIDI clients &amp; ports and dumping MIDI sequencer events:</p> <p>List all ports:</p> python -m linuxpy.midi.cli ls Port   Client                   Port                     Type                           Capabilities  0:0   System                   Timer                    0                              SR, W, R  0:1   System                   Announce                 0                              SR, R 14:0   Midi Through             Midi Through Port-0      PORT, SOFTWARE, MIDI_GENERIC   SW, SR, W, R <p>Listen to events on selected port(s):</p> python -m linuxpy.midi.cli listen 0:1 14:0   0:1   Port subscribed      sender=(client=0, port=1), dest=(client=128, port=0)   0:1   Port start           client=128, port=1   0:1   Port subscribed      sender=(client=14, port=0), dest=(client=128, port=1)   0:1   Client start         client=130, port=0   0:1   Port start           client=130, port=0   0:1   Port subscribed      sender=(client=130, port=0), dest=(client=14, port=0)  14:0   Note on              channel=0, note=100, velocity=3, off_velocity=0, duration=0   0:1   Port unsubscribed    sender=(client=130, port=0), dest=(client=14, port=0)   0:1   Port exit            client=130, port=0   0:1   Client exit          client=130, port=0   0:1   Port exit            client=129, port=0   0:1   Client exit          client=129, port=0   0:1   Client start         client=129, port=0   0:1   Port start           client=129, port=0  14:0   Note on              channel=0, note=100, velocity=3, off_velocity=0, duration=0  14:0   Note on              channel=0, note=0, velocity=255, off_velocity=0, duration=0  14:0   Note on              channel=0, note=0, velocity=255, off_velocity=0, duration=0"},{"location":"user_guide/thermal/","title":"\ud83c\udf21\ufe0f Thermal and cooling","text":"<p>Human friendly interface to linux thermal zone and cooling devices.</p> <p>Without further ado:</p> python from linuxpy.thermal import find with find(type=\"x86_pkg_temp\") as tz:     print(f\"X86 temperature: {tz.temperature/1000:6.2f} C\") X86 temperature:  63.00 C"},{"location":"user_guide/video/","title":"\ud83c\udfa5 Video","text":"<p>Human friendly interface to the Video for Linux 2 (V4L2) subsystem.</p> <p></p> <p>Without further ado:</p> python from linuxpy.video.device import Device with Device.from_id(0) as cam:     for i, frame in enumerate(cam):         print(f\"frame #{i}: {len(frame)} bytes\") frame #0: 54630 bytes frame #1: 50184 bytes frame #2: 44054 bytes frame #3: 42822 bytes frame #4: 42116 bytes frame #5: 41868 bytes frame #6: 41322 bytes frame #7: 40896 bytes frame #8: 40844 bytes frame #9: 40714 bytes frame #10: 40662 bytes ..."},{"location":"user_guide/video/#device-creation","title":"Device creation","text":"<p>Create a device object from an ID:</p> <pre><code>from linuxpy.video.device import Device\ncamera = Device.from_id(10)\n</code></pre> <p>from a filename: <pre><code>from linuxpy.video.device import Device\ncamera = Device(\"/dev/video10\")\n</code></pre></p> <p>or from an existing file object:</p> <pre><code>from linuxpy.video.device import Device\nwith open(\"/dev/video10\", \"rb+\", buffering=0) as fd:\n    camera = Device(fd)\n</code></pre> <p>Before using video <code>Device</code> object you need to open it (except in the example directly above when creating a device from a file object). You can either use the device object as a context manager (prefered):</p> <pre><code>with Device.from_id(10) as camera:\n    ...\n</code></pre> <p>The Device object is a reusable, reentrant but not thread safe context manager. This means that Device object can not only be used in multiple with statements, but may also be used inside a with statement that is already using the same context manager.</p> <p>So the following examples will work just fine:</p> <pre><code>with Device.from_id(10) as camera:\n    ...\n    with camera:\n        ...\n\nwith camera:\n    ...\n</code></pre> <p>Alternatively, you can manage calls <code>Device.open()</code>/<code>Device.close()</code> manually:</p> <pre><code>camera = Device.from_id(10)\ncamera.open()\ntry:\n    ...\nfinally:\n    camera.close()\n</code></pre>"},{"location":"user_guide/video/#capture","title":"Capture","text":"<p>Simple capture without any configuration is possible using the Device object as an infinite iterator:</p> <pre><code>from linuxpy.video.device import Device, VideoCapture\n\nwith Device.from_id(0) as camera:\n    for frame in camera:\n        ...\n</code></pre> <p>The resulting <code>Frame</code> objects can safely and efficiently be converted to bytes.</p> <p>To be able to configure the acquisition, you will need to use the <code>VideoCapture</code> helper. Here is an example with image size and format configuration:</p> <pre><code>from linuxpy.video.device import Device, VideoCapture\n\nwith Device.from_id(0) as camera:\n    capture = VideoCapture(camera)\n    capture.set_format(640, 480, \"MJPG\")\n    with capture:\n        for frame in capture:\n            ...\n</code></pre> <p>Note that <code>VideoCapture</code> configuration must be done before the capture is started (ie, the <code>with capture:</code> statement.)</p> <p>By default, VideoCapture will use memory map if the device has STREAMING capability and falls back to standard read if not. It is also possible to force a specific reader:</p> <pre><code>from linuxpy.video.device import Capability, Device, VideoCapture\n\nwith Device.from_id(0) as cam:\n    with VideoCapture(cam, source=Capability.READWRITE):\n        for frame in capture:\n            ...\n</code></pre>"},{"location":"user_guide/video/#information","title":"Information","text":"<p>Getting information about the device:</p> <pre><code>&gt;&gt;&gt; from linuxpy.video.device import Device, BufferType\n\n&gt;&gt;&gt; cam = Device.from_id(0)\n&gt;&gt;&gt; cam.open()\n&gt;&gt;&gt; cam.info.card\n'Integrated_Webcam_HD: Integrate'\n\n&gt;&gt;&gt; cam.info.capabilities\n&lt;Capability.STREAMING|EXT_PIX_FORMAT|VIDEO_CAPTURE: 69206017&gt;\n\n&gt;&gt;&gt; cam.info.formats\n[ImageFormat(type=&lt;BufferType.VIDEO_CAPTURE: 1&gt;, description=b'Motion-JPEG',\n             flags=&lt;ImageFormatFlag.COMPRESSED: 1&gt;, pixelformat=&lt;PixelFormat.MJPEG: 1196444237&gt;),\n ImageFormat(type=&lt;BufferType.VIDEO_CAPTURE: 1&gt;, description=b'YUYV 4:2:2',\n             flags=&lt;ImageFormatFlag.0: 0&gt;, pixelformat=&lt;PixelFormat.YUYV: 1448695129&gt;)]\n\n&gt;&gt;&gt; cam.get_format(BufferType.VIDEO_CAPTURE)\nFormat(width=640, height=480, pixelformat=&lt;PixelFormat.MJPEG: 1196444237&gt;}\n\n&gt;&gt;&gt; for ctrl in cam.controls.values(): print(ctrl)\n&lt;IntegerControl brightness min=0 max=255 step=1 default=128 value=128&gt;\n&lt;IntegerControl contrast min=0 max=255 step=1 default=32 value=32&gt;\n&lt;IntegerControl saturation min=0 max=100 step=1 default=64 value=64&gt;\n&lt;IntegerControl hue min=-180 max=180 step=1 default=0 value=0&gt;\n&lt;BooleanControl white_balance_automatic default=True value=True&gt;\n&lt;IntegerControl gamma min=90 max=150 step=1 default=120 value=120&gt;\n&lt;MenuControl power_line_frequency default=1 value=1&gt;\n&lt;IntegerControl white_balance_temperature min=2800 max=6500 step=1 default=4000 value=4000 flags=inactive&gt;\n&lt;IntegerControl sharpness min=0 max=7 step=1 default=2 value=2&gt;\n&lt;IntegerControl backlight_compensation min=0 max=2 step=1 default=1 value=1&gt;\n&lt;MenuControl auto_exposure default=3 value=3&gt;\n&lt;IntegerControl exposure_time_absolute min=4 max=1250 step=1 default=156 value=156 flags=inactive&gt;\n&lt;BooleanControl exposure_dynamic_framerate default=False value=False&gt;\n\n&gt;&gt;&gt; cam.controls[\"saturation\"]\n&lt;IntegerControl saturation min=0 max=100 step=1 default=64 value=64&gt;\n\n&gt;&gt;&gt; cam.controls[\"saturation\"].id\n9963778\n&gt;&gt;&gt; cam.controls[9963778]\n&lt;IntegerControl saturation min=0 max=100 step=1 default=64 value=64&gt;\n\n&gt;&gt;&gt; cam.controls.brightness\n&lt;IntegerControl brightness min=0 max=255 step=1 default=128 value=128&gt;\n&gt;&gt;&gt; cam.controls.brightness.value = 64\n&gt;&gt;&gt; cam.controls.brightness\n&lt;IntegerControl brightness min=0 max=255 step=1 default=128 value=64&gt;\n</code></pre> <p>(see also v4l2py-ctl example)</p>"},{"location":"user_guide/video/#asyncio","title":"asyncio","text":"<p>linuxpy.video is asyncio friendly:</p> python -m asyncio from linuxpy.video.device import Device with Device.from_id(0) as cam:     async for frame in cam:         print(f\"frame {len(frame)}\") frame 10224 frame 10304 frame 10136 ... <p>(check basic async and web async examples)</p>"},{"location":"user_guide/video/#gevent","title":"gevent","text":"<p>linuxpy.video is also gevent friendly:</p> <pre><code>&gt;&gt;&gt; from linuxpy.io import GeventIO\n&gt;&gt;&gt; from linuxpy.video.device import Device\n&gt;&gt;&gt; with Device.from_id(0, io=GeventIO) as camera:\n...     for frame in camera:\n...         print(f\"frame {len(frame)}\")\nframe 10224\nframe 10304\nframe 10224\nframe 10136\n...\n</code></pre> <p>(check basic gevent and web gevent examples)</p>"},{"location":"user_guide/video/#video-output","title":"Video output","text":"<p>It is possible to write to a video output capable device (ex: v4l2loopback). The following example shows how to grab frames from device 0 and write them to device 10:</p> <pre><code>&gt;&gt;&gt; from linuxpy.video.device import Device, VideoOutput, BufferType\n&gt;&gt;&gt; dev_source = Device.from_id(0)\n&gt;&gt;&gt; dev_sink = Device.from_id(10)\n&gt;&gt;&gt; with dev_source, dev_target:\n&gt;&gt;&gt;     source = VideoCapture(dev_source)\n&gt;&gt;&gt;     sink = VideoOutput(dev_sink)\n&gt;&gt;&gt;     source.set_format(640, 480, \"MJPG\")\n&gt;&gt;&gt;     sink.set_format(640, 480, \"MJPG\")\n&gt;&gt;&gt;     with source, sink:\n&gt;&gt;&gt;         for frame in source:\n&gt;&gt;&gt;             sink.write(frame.data)\n</code></pre> <p>By default, VideoOutput will use memory map if the device has STREAMING capability and falls back to standard write if not. It is also possible to force a specific writer with <code>VideoOutput(cam, sink=Capability.READWRITE)</code>:</p>"},{"location":"user_guide/video/#v4l2loopback","title":"v4l2loopback","text":"<p>This is just an example on how to setup v4l2loopback.</p> <p>Start from scratch:</p> <pre><code># Remove kernel module and all devices (no client can be connected at this point)\nsudo modprobe -r v4l2loopback\n\n# Install some devices\nsudo modprobe v4l2loopback video_nr=20,21 card_label=\"Loopback 0\",\"Loopback 1\"\n</code></pre>"},{"location":"user_guide/video/#references","title":"References","text":"<p>See the <code>linux/videodev2.h</code> header file for details.</p> <ul> <li>V4L2 (Latest) (videodev.h)</li> <li>V4L2 6.2 (videodev.h)</li> </ul>"},{"location":"coverage/","title":"Coverage report","text":""}]}
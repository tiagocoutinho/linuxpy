{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to linuxpy","text":"<p>Human friendly interface to linux subsystems using python.</p> <p>Provides python access to several linux subsystems like V4L2, input and MIDI.</p> <p>There is experimental, incomplete and unstable access to USB.</p> <p>Only works on python &gt;= 3.9.</p>"},{"location":"#installation","title":"Installation","text":"<p>From within your favorite python environment:</p> <pre><code>$ pip install linuxpy\n</code></pre> <p>To run the examples you'll need:</p> <pre><code>$ pip install linuxpy[examples]\n</code></pre> <p>To develop, run tests, build package, lint, etc you'll need:</p> <pre><code>$ pip install linuxpy[dev]\n</code></pre> <p>To run docs you'll need:</p> <pre><code>$ pip install linuxpy[docs]\n</code></pre>"},{"location":"input/","title":"Input","text":"<p>API not documented yet. Just this example:</p> <pre><code>import time\nfrom linuxpy.input.device import find_gamepads\n\npad = next(find_gamepads())\nabs = pad.absolute\n\nwith pad:\n    while True:\n        print(f\"X:{abs.x:&gt;3} | Y:{abs.y:&gt;3} | RX:{abs.rx:&gt;3} | RY:{abs.ry:&gt;3}\", end=\"\\r\", flush=True)\n        time.sleep(0.1)\n</code></pre>"},{"location":"input/#asyncio","title":"asyncio","text":"<pre><code>$ python -m asyncio\n\n&gt;&gt;&gt; from linuxpy.input.device import find_gamepads\n&gt;&gt;&gt; with next(find_gamepads()) as pad:\n...     async for event in pad:\n...         print(event)\nInputEvent(time=1697520475.348099, type=&lt;EventType.SYN: 0&gt;, code=&lt;Synchronization.REPORT: 0&gt;, value=0)\nInputEvent(time=1697520475.361564, type=&lt;EventType.REL: 2&gt;, code=&lt;Relative.X: 0&gt;, value=-1)\nInputEvent(time=1697520475.361564, type=&lt;EventType.REL: 2&gt;, code=&lt;Relative.Y: 1&gt;, value=1)\nInputEvent(time=1697520475.361564, type=&lt;EventType.SYN: 0&gt;, code=&lt;Synchronization.REPORT: 0&gt;, value=0)\nInputEvent(time=1697520475.371128, type=&lt;EventType.REL: 2&gt;, code=&lt;Relative.X: 0&gt;, value=-1)\nInputEvent(time=1697520475.371128, type=&lt;EventType.SYN: 0&gt;, code=&lt;Synchronization.REPORT: 0&gt;, value=0)\nInputEvent(time=1697520475.384468, type=&lt;EventType.REL: 2&gt;, code=&lt;Relative.X: 0&gt;, value=-1)\nInputEvent(time=1697520475.384468, type=&lt;EventType.REL: 2&gt;, code=&lt;Relative.Y: 1&gt;, value=1)\nInputEvent(time=1697520475.384468, type=&lt;EventType.SYN: 0&gt;, code=&lt;Synchronization.REPORT: 0&gt;, value=0)\nInputEvent(time=1697520475.398041, type=&lt;EventType.REL: 2&gt;, code=&lt;Relative.X: 0&gt;, value=-2)\nInputEvent(time=1697520475.398041, type=&lt;EventType.REL: 2&gt;, code=&lt;Relative.Y: 1&gt;, value=1)\nInputEvent(time=1697520475.398041, type=&lt;EventType.SYN: 0&gt;, code=&lt;Synchronization.REPORT: 0&gt;, value=0)\nInputEvent(time=1697520475.424895, type=&lt;EventType.REL: 2&gt;, code=&lt;Relative.X: 0&gt;, value=-1)\nInputEvent(time=1697520475.424895, type=&lt;EventType.SYN: 0&gt;, code=&lt;Synchronization.REPORT: 0&gt;, value=0)\n...\n</code></pre>"},{"location":"input/#references","title":"References","text":"<ul> <li>Input (Latest)</li> <li>Input 6.2</li> </ul>"},{"location":"midi/","title":"MIDI Sequencer","text":"<p>Without further ado:</p> <pre><code>$ python\n\n&gt;&gt;&gt; from linuxpy.midi.device import Sequencer\n&gt;&gt;&gt; with Sequencer() as seq:\n        port = seq.create_port()\n        port.connect_from(14, 0)\n        for event in seq:\n            print(event)\n 14:0   Note on              channel=0, note=100, velocity=3, off_velocity=0, duration=0\n 14:0   Clock                queue=0, pad=b''\n 14:0   System exclusive     F0 61 62 63 F7\n 14:0   Note off             channel=0, note=55, velocity=3, off_velocity=0, duration=0\n</code></pre>"},{"location":"midi/#system-information","title":"System information","text":"<pre><code>$ python\n\n&gt;&gt;&gt; from linuxpy.midi.device import Sequencer\n&gt;&gt;&gt; seq = Sequencer(\"a midi client\")\n&gt;&gt;&gt; seq.open()\n\n&gt;&gt;&gt; seq.version\n1.0.2\n\n&gt;&gt;&gt; seq.client_info\nsnd_seq_client_info(client=128, type=1, name=b'a midi client', filter=0, multicast_filter=b'', event_filter=b'', num_ports=0, event_lost=0, card=-1, pid=1288570, reserved=b'')\n\n&gt;&gt;&gt; seq.running_mode\nsnd_seq_running_info(client=0, big_endian=0, cpu_mode=0, pad=0, reserved=b'')\n\n&gt;&gt;&gt; seq.system_info\nsnd_seq_system_info(queues=32, clients=192, ports=254, channels=256, cur_clients=3, cur_queues=0, reserved=b'')\n</code></pre>"},{"location":"midi/#listing-ports-and-clients","title":"Listing ports and clients","text":""},{"location":"midi/#asyncio","title":"asyncio","text":"<p>asyncio is a first class citizen to linuxpy.midi:</p> <pre><code>$ python -m asyncio\n\n&gt;&gt;&gt; from linuxpy.midi.device import Sequencer\n&gt;&gt;&gt; with Sequencer() as seq:\n        port = seq.create_port()\n        port.connect_from(14, 0)\n        async for event in seq:\n            print(event)\n 14:0   Note on              channel=0, note=100, velocity=3, off_velocity=0, duration=0\n 14:0   Clock                queue=0, pad=b''\n 14:0   System exclusive     F0 61 62 63 F7\n 14:0   Note off             channel=0, note=55, velocity=3, off_velocity=0, duration=0\n</code></pre>"},{"location":"midi/#cli","title":"CLI","text":"<p>A basic CLI is provided that allows listing MIDI clients &amp; ports and dumping MIDI sequencer events:</p> <pre><code>$ python -m linuxpy.midi.cli ls\n Port   Client                   Port                     Type                           Capabilities\n  0:0   System                   Timer                    0                              SR, W, R\n  0:1   System                   Announce                 0                              SR, R\n 14:0   Midi Through             Midi Through Port-0      PORT, SOFTWARE, MIDI_GENERIC   SW, SR, W, R\n</code></pre> <pre><code>$ python -m linuxpy.midi.cli listen 0:1 14:0\n  0:1   Port subscribed      sender=(client=0, port=1), dest=(client=128, port=0)\n  0:1   Port start           client=128, port=1\n  0:1   Port subscribed      sender=(client=14, port=0), dest=(client=128, port=1)\n  0:1   Client start         client=130, port=0\n  0:1   Port start           client=130, port=0\n  0:1   Port subscribed      sender=(client=130, port=0), dest=(client=14, port=0)\n 14:0   Note on              channel=0, note=100, velocity=3, off_velocity=0, duration=0\n  0:1   Port unsubscribed    sender=(client=130, port=0), dest=(client=14, port=0)\n  0:1   Port exit            client=130, port=0\n  0:1   Client exit          client=130, port=0\n  0:1   Port exit            client=129, port=0\n  0:1   Client exit          client=129, port=0\n  0:1   Client start         client=129, port=0\n  0:1   Port start           client=129, port=0\n 14:0   Note on              channel=0, note=100, velocity=3, off_velocity=0, duration=0\n 14:0   Note on              channel=0, note=0, velocity=255, off_velocity=0, duration=0\n 14:0   Note on              channel=0, note=0, velocity=255, off_velocity=0, duration=0\n</code></pre>"},{"location":"video/","title":"Video","text":"<p>Video for Linux 2 (V4L2).</p> <p>Without further ado:</p> <pre><code>&gt;&gt;&gt; from linuxpy.video.device import Device\n&gt;&gt;&gt; with Device.from_id(0) as cam:\n&gt;&gt;&gt;     for i, frame in enumerate(cam):\n...         print(f\"frame #{i}: {len(frame)} bytes\")\n...         if i &gt; 9:\n...             break\n...\nframe #0: 54630 bytes\nframe #1: 50184 bytes\nframe #2: 44054 bytes\nframe #3: 42822 bytes\nframe #4: 42116 bytes\nframe #5: 41868 bytes\nframe #6: 41322 bytes\nframe #7: 40896 bytes\nframe #8: 40844 bytes\nframe #9: 40714 bytes\nframe #10: 40662 bytes\n</code></pre>"},{"location":"video/#capture","title":"Capture","text":"<p>Simple capture without any configuration is possible using the Device object as an iterator:</p> <pre><code>from linuxpy.video.device import Device, VideoCapture\n\nwith Device.from_id(0) as cam:\n    for frame in cam:\n        ...\n</code></pre> <p>To be able to configure the next acquisition, you will need to use the <code>VideoCapture</code> helper. Here is an example with image size and format configuration:</p> <pre><code>from linuxpy.video.device import Device, VideoCapture\n\nwith Device.from_id(0) as cam:\n    capture = VideoCapture(cam)\n    capture.set_format(640, 480, \"MJPG\")\n    with VideoCapture(cam) as capture:\n        for frame in capture:\n            ...\n</code></pre> <p>By default, VideoCapture will use memory map if the device has STREAMING capability and falls back to standard read if not. It is also possible to force a specific reader:</p> <pre><code>from linuxpy.video.device import Capability, Device, VideoCapture\n\nwith Device.from_id(0) as cam:\n    capture = VideoCapture(cam, source=Capability.READWRITE)\n    capture.set_format(640, 480, \"MJPG\")\n    with VideoCapture(cam) as capture:\n        for frame in capture:\n            ...\n</code></pre>"},{"location":"video/#information","title":"Information","text":"<p>Getting information about the device:</p> <pre><code>&gt;&gt;&gt; from linuxpy.video.device import Device, BufferType\n\n&gt;&gt;&gt; cam = Device.from_id(0)\n&gt;&gt;&gt; cam.open()\n&gt;&gt;&gt; cam.info.card\n'Integrated_Webcam_HD: Integrate'\n\n&gt;&gt;&gt; cam.info.capabilities\n&lt;Capability.STREAMING|EXT_PIX_FORMAT|VIDEO_CAPTURE: 69206017&gt;\n\n&gt;&gt;&gt; cam.info.formats\n[ImageFormat(type=&lt;BufferType.VIDEO_CAPTURE: 1&gt;, description=b'Motion-JPEG',\n             flags=&lt;ImageFormatFlag.COMPRESSED: 1&gt;, pixelformat=&lt;PixelFormat.MJPEG: 1196444237&gt;),\n ImageFormat(type=&lt;BufferType.VIDEO_CAPTURE: 1&gt;, description=b'YUYV 4:2:2',\n             flags=&lt;ImageFormatFlag.0: 0&gt;, pixelformat=&lt;PixelFormat.YUYV: 1448695129&gt;)]\n\n&gt;&gt;&gt; cam.get_format(BufferType.VIDEO_CAPTURE)\nFormat(width=640, height=480, pixelformat=&lt;PixelFormat.MJPEG: 1196444237&gt;}\n\n&gt;&gt;&gt; for ctrl in cam.controls.values(): print(ctrl)\n&lt;IntegerControl brightness min=0 max=255 step=1 default=128 value=128&gt;\n&lt;IntegerControl contrast min=0 max=255 step=1 default=32 value=32&gt;\n&lt;IntegerControl saturation min=0 max=100 step=1 default=64 value=64&gt;\n&lt;IntegerControl hue min=-180 max=180 step=1 default=0 value=0&gt;\n&lt;BooleanControl white_balance_automatic default=True value=True&gt;\n&lt;IntegerControl gamma min=90 max=150 step=1 default=120 value=120&gt;\n&lt;MenuControl power_line_frequency default=1 value=1&gt;\n&lt;IntegerControl white_balance_temperature min=2800 max=6500 step=1 default=4000 value=4000 flags=inactive&gt;\n&lt;IntegerControl sharpness min=0 max=7 step=1 default=2 value=2&gt;\n&lt;IntegerControl backlight_compensation min=0 max=2 step=1 default=1 value=1&gt;\n&lt;MenuControl auto_exposure default=3 value=3&gt;\n&lt;IntegerControl exposure_time_absolute min=4 max=1250 step=1 default=156 value=156 flags=inactive&gt;\n&lt;BooleanControl exposure_dynamic_framerate default=False value=False&gt;\n\n&gt;&gt;&gt; cam.controls[\"saturation\"]\n&lt;IntegerControl saturation min=0 max=100 step=1 default=64 value=64&gt;\n\n&gt;&gt;&gt; cam.controls[\"saturation\"].id\n9963778\n&gt;&gt;&gt; cam.controls[9963778]\n&lt;IntegerControl saturation min=0 max=100 step=1 default=64 value=64&gt;\n\n&gt;&gt;&gt; cam.controls.brightness\n&lt;IntegerControl brightness min=0 max=255 step=1 default=128 value=128&gt;\n&gt;&gt;&gt; cam.controls.brightness.value = 64\n&gt;&gt;&gt; cam.controls.brightness\n&lt;IntegerControl brightness min=0 max=255 step=1 default=128 value=64&gt;\n</code></pre> <p>(see also v4l2py-ctl example)</p>"},{"location":"video/#asyncio","title":"asyncio","text":"<p>linuxpy.video is asyncio friendly:</p> <pre><code>$ python -m asyncio\n\n&gt;&gt;&gt; from linuxpy.video.device import Device\n&gt;&gt;&gt; with Device.from_id(0) as camera:\n...     async for frame in camera:\n...         print(f\"frame {len(frame)}\")\nframe 10224\nframe 10304\nframe 10224\nframe 10136\n...\n</code></pre> <p>(check basic async and web async examples)</p>"},{"location":"video/#gevent","title":"gevent","text":"<p>linuxpy.video is also gevent friendly:</p> <pre><code>$ python\n\n&gt;&gt;&gt; from linuxpy.io import GeventIO\n&gt;&gt;&gt; from linuxpy.video.device import Device\n&gt;&gt;&gt; with Device.from_id(0, io=GeventIO) as camera:\n...     for frame in camera:\n...         print(f\"frame {len(frame)}\")\nframe 10224\nframe 10304\nframe 10224\nframe 10136\n...\n</code></pre> <p>(check basic gevent and web gevent examples)</p>"},{"location":"video/#video-output","title":"Video output","text":"<p>It is possible to write to a video output capable device (ex: v4l2loopback). The following example shows how to grab frames from device 0 and write them to device 10:</p> <pre><code>&gt;&gt;&gt; from linuxpy.video.device import Device, VideoOutput, BufferType\n&gt;&gt;&gt; dev_source = Device.from_id(0)\n&gt;&gt;&gt; dev_sink = Device.from_id(10)\n&gt;&gt;&gt; with dev_source, dev_target:\n&gt;&gt;&gt;     source = VideoCapture(dev_source)\n&gt;&gt;&gt;     sink = VideoOutput(dev_sink)\n&gt;&gt;&gt;     source.set_format(640, 480, \"MJPG\")\n&gt;&gt;&gt;     sink.set_format(640, 480, \"MJPG\")\n&gt;&gt;&gt;     with source, sink:\n&gt;&gt;&gt;         for frame in source:\n&gt;&gt;&gt;             sink.write(frame.data)\n</code></pre> <p>By default, VideoOutput will use memory map if the device has STREAMING capability and falls back to standard write if not. It is also possible to force a specific writer with <code>VideoOutput(cam, sink=Capability.READWRITE)</code>:</p>"},{"location":"video/#v4l2loopback","title":"v4l2loopback","text":"<p>This is just an example on how to setup v4l2loopback.</p> <p>Start from scratch: <pre><code># Remove kernel module and all devices (no client can be connected at this point)\nsudo modprobe -r v4l2loopback\n\n# Install some devices\nsudo modprobe v4l2loopback video_nr=20,21 card_label=\"Loopback 0\",\"Loopback 1\"\n</code></pre></p>"},{"location":"video/#references","title":"References","text":"<p>See the <code>linux/videodev2.h</code> header file for details.</p> <ul> <li>V4L2 (Latest) (videodev.h)</li> <li>V4L2 6.2 (videodev.h)</li> </ul>"}]}
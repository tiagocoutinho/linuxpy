{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to linuxpy","text":"<p>Human friendly interface to linux subsystems using python.</p> <p>Provides python access to several linux subsystems like V4L2, input and MIDI.</p> <p>There is experimental, incomplete and unstable access to USB.</p> <p>Need fine control over Webcams, MIDI devices, input devices (joysticks, gamepads, keyboards, mice or even the keyboard light on your laptop)? Linuxpy has your back.</p> <p>Only works on python &gt;= 3.9.</p>"},{"location":"#installation","title":"Installation","text":"<p>From within your favorite python environment:</p> pip install linuxpy <p>To run the examples you'll need:</p> pip install linuxpy[examples] <p>To develop, run tests, build package, lint, etc you'll need:</p> pip install linuxpy[dev] <p>To run docs you'll need:</p> pip install linuxpy[docs]"},{"location":"develop/","title":"Developers corner","text":""},{"location":"develop/#requirements","title":"Requirements","text":"<p>A linux OS and python &gt;= 3.9.</p> <p>From within your favorite python environment:</p> <pre><code>$ pip install linuxpy[dev]\n</code></pre> <p>Additionally, to run the code generation tool you'll need <code>castxml</code> installed on your system.</p> <p>On a debian based run:</p> <pre><code>$ apt install castxml\n</code></pre>"},{"location":"develop/#code-generation","title":"Code generation","text":"<p>This project uses an internal simple code generator that reads linux kernel header files and produces several <code>raw.py</code> ctypes based python files for each sub-system.</p> <p>To re-generate these files for a newer linux kernel (or fix a bug) you'll need linux header files installed on your system + black.</p> <p>To launch the tool call:</p> <pre><code>$ python -m linuxpy.codegen.cli\n</code></pre>"},{"location":"develop/#running-tests","title":"Running tests","text":"<p>Some video tests will only run with a properly configured <code>v4l2loopback</code>.</p> <pre><code>$ sudo modprobe v4l2loopback video_nr=199 card_label=\"Loopback 199\"\n</code></pre> <p>Additionally the user which runs the tests will need read/write access to <code>/dev/video199</code>. On most systems this can be achieved by adding the user to the <code>video</code> group:</p> <pre><code>$ sudo addgroup $USER video\n</code></pre> <p>Some input tests require the user which runs the tests to have read/write access to <code>/dev/uinput</code>. On most systems this can be achieved by adding the user to the <code>input</code> group:</p> <pre><code>$ sudo addgroup $USER input\n</code></pre>"},{"location":"api/","title":"LinuxPy reference API","text":"<p>Here's the reference or code API, the classes, functions, parameters, attributes, and all the LinuxPy parts you can use in your applications.</p> <p>If you want to learn LinuxPy you are much better off reading the LinuxPy User Guide.</p>"},{"location":"api/input/","title":"Input","text":""},{"location":"api/input/#input-api-reference","title":"Input API reference","text":""},{"location":"api/input/#linuxpy.input.device","title":"<code>linuxpy.input.device</code>","text":""},{"location":"api/input/#linuxpy.input.device.Device","title":"<code>Device(*args, **kwargs)</code>","text":"<p>             Bases: <code>BaseDevice</code></p>"},{"location":"api/input/#linuxpy.input.device.Device.read_event","title":"<code>read_event()</code>","text":"<p>Read event. Event must be available to read or otherwise will raise an error</p>"},{"location":"api/input/#linuxpy.input.device.EventReader","title":"<code>EventReader(device: Device, max_queue_size=1)</code>","text":""},{"location":"api/input/#linuxpy.input.device.EventReader.aread","title":"<code>aread()</code>  <code>async</code>","text":"<p>Wait for next event or return last event</p>"},{"location":"api/input/#linuxpy.input.device.BaseUDevice","title":"<code>BaseUDevice(filename=PATH, bus=Bus.USB, vendor_id=1, product_id=1, name='linuxpy emulated device')</code>","text":"<p>             Bases: <code>BaseDevice</code></p> <p>A uinput device with no capabilities registered</p>"},{"location":"api/input/#linuxpy.input.device.iter_input_files","title":"<code>iter_input_files(path='/dev/input', pattern='event*')</code>","text":"<p>List readable character devices in the given path.</p>"},{"location":"api/input/#linuxpy.input.device.event_batch_stream","title":"<code>event_batch_stream(fd)</code>","text":"<p>Yields packets of events occurring at the same moment in time.</p>"},{"location":"api/input/#linuxpy.input.device.async_event_batch_stream","title":"<code>async_event_batch_stream(fd, maxsize=1000)</code>  <code>async</code>","text":"<p>Yields packets of events occurring at the same moment in time.</p>"},{"location":"api/midi/","title":"MIDI API reference","text":""},{"location":"api/midi/#linuxpy.midi.device","title":"<code>linuxpy.midi.device</code>","text":"<p>Human API to linux MIDI subsystem.</p> <p>The heart of linuxpy MIDI library is the <code>Sequencer</code> class. Usually you need only one instance of Sequencer for your application. The recommended way is to use it within a context manager like:</p> <pre><code>with Sequencer(\"My MIDI App\") as midi:\n    print(f\"MIDI version: {midi.version}\")\n</code></pre> <p>which is roughly equivalent to:</p> <pre><code>midi = Sequencer(\"My MIDI App\")\nmidi.open()\ntry:\n    print(f\"MIDI version: {midi.version}\")\nfinally:\n    midi.close()\n</code></pre> <p>Here's a real world example:</p> <pre><code>from linuxpy.midi.device import Sequencer\n\nwith Sequencer(\"My MIDI App\") as midi:\n    print(f\"I'm client {midi.client_id}\")\n    print(f\"MIDI version: {midi.version}\")\n    port = midi.create_port()\n    port.connect_from((0, 1))\n    for event in midi:\n        print(event)\n</code></pre>"},{"location":"api/midi/#linuxpy.midi.device.Sequencer","title":"<code>Sequencer(name: str = 'linuxpy client', **kwargs)</code>","text":"<p>             Bases: <code>BaseDevice</code></p> <p>Central MIDI object.</p> <pre><code>from linuxpy.midi.device import Sequencer\n\nwith Sequencer(\"My MIDI App\") as midi:\n    print(f\"I'm client {midi.client_id}\")\n    print(f\"MIDI version: {midi.version}\")\n    port = midi.create_port()\n    port.connect_from((0, 1))\n    for event in midi:\n        print(event)\n</code></pre>"},{"location":"api/midi/#linuxpy.midi.device.Sequencer.client_info","title":"<code>client_info: snd_seq_client_info</code>  <code>property</code>","text":"<p>Current Client information</p>"},{"location":"api/midi/#linuxpy.midi.device.Sequencer.client","title":"<code>client: Client</code>  <code>property</code>","text":"<p>Current Client information</p>"},{"location":"api/midi/#linuxpy.midi.device.Sequencer.running_mode","title":"<code>running_mode: snd_seq_running_info</code>  <code>property</code>","text":"<p>Current running mode</p>"},{"location":"api/midi/#linuxpy.midi.device.Sequencer.system_info","title":"<code>system_info: snd_seq_system_info</code>  <code>property</code>","text":"<p>Current system information</p>"},{"location":"api/midi/#linuxpy.midi.device.Sequencer.iter_clients","title":"<code>iter_clients: Iterable[Client]</code>  <code>property</code>","text":"<p>An iterator over all open clients on the system. It returns new Client each time</p>"},{"location":"api/midi/#linuxpy.midi.device.Sequencer.clients","title":"<code>clients: Sequence[Client]</code>  <code>property</code>","text":"<p>Returns a new list of all clients on the system</p>"},{"location":"api/midi/#linuxpy.midi.device.Sequencer.iter_ports","title":"<code>iter_ports: Iterable[Port]</code>  <code>property</code>","text":"<p>An iterator over all open ports on the system. It returns new Port objects each time</p>"},{"location":"api/midi/#linuxpy.midi.device.Sequencer.ports","title":"<code>ports: Sequence[Port]</code>  <code>property</code>","text":"<p>Returns a new list of all open ports on the system. It returns new Port objects each time</p>"},{"location":"api/midi/#linuxpy.midi.device.Sequencer.__iter__","title":"<code>__iter__() -&gt; Iterable[Event]</code>","text":"<p>Build an infinite iterator that streams MIDI events from the subscribed ports. You'll need an open sequencer before using it:</p> <pre><code>from linuxpy.midi.device import Sequencer\n\nwith Sequencer() as midi:\n    port = midi.create_port()\n    port.connect_from((0, 1))\n    for event in midi:\n        print(event)\n</code></pre>"},{"location":"api/midi/#linuxpy.midi.device.Sequencer.__aiter__","title":"<code>__aiter__() -&gt; AsyncIterable[Event]</code>  <code>async</code>","text":"<p>Build an infinite async iterator that streams MIDI events from the subscribed ports. You'll need an open sequencer before using it:</p> <pre><code>import asyncio\nfrom linuxpy.midi.device import Sequencer\n\nasync def main():\n    with Sequencer() as midi:\n        port = midi.create_port()\n        port.connect_from((0, 1))\n        async for event in midi:\n            print(event)\n\nasyncio.run(main())\n</code></pre>"},{"location":"api/midi/#linuxpy.midi.device.Sequencer.get_client","title":"<code>get_client(client_id: int) -&gt; Client</code>","text":"<p>Returns a Client for the given ID or raises an error if the client doesn't exist. It returns new Client object each time</p>"},{"location":"api/midi/#linuxpy.midi.device.Sequencer.get_port","title":"<code>get_port(address: FullPortAddress) -&gt; Port</code>","text":"<p>Returns a Port for the given address or raises an error if the port doesn't exist. It returns new Port object each time</p>"},{"location":"api/midi/#linuxpy.midi.device.Sequencer.create_port","title":"<code>create_port(name: str = 'linuxpy port', capabilities: PortCapability = INPUT_OUTPUT, port_type: PortType = PortType.MIDI_GENERIC | PortType.APPLICATION) -&gt; Port</code>","text":"<p>Create a new local port. By default it will create a MIDI generic application Input/Output port.</p>"},{"location":"api/midi/#linuxpy.midi.device.Sequencer.delete_port","title":"<code>delete_port(port: Union[int, Port])</code>","text":"<p>Delete a previously created local port. If the port has any subscriptions they will be closed before the port is deleted</p>"},{"location":"api/midi/#linuxpy.midi.device.Sequencer.subscribe","title":"<code>subscribe(src: FullPortAddress, dest: FullPortAddress)</code>","text":"<p>Subscribe a source port to a destination port</p>"},{"location":"api/midi/#linuxpy.midi.device.Sequencer.unsubscribe","title":"<code>unsubscribe(src: FullPortAddress, dest: FullPortAddress)</code>","text":"<p>Unsubscribe a previously subscribed source port to a destination port</p>"},{"location":"api/midi/#linuxpy.midi.device.Sequencer.iter_raw_read","title":"<code>iter_raw_read(max_nb_packets: int = 64) -&gt; Iterable[Event]</code>","text":"<p>Read list of pending events. If the sequencer is opened in blocking mode and there are no events it blocks until at least one event occurs otherwise as OSError is raised.</p> <p>Use the <code>read()</code> call instead because it handles blocking vs non-blocking variants transperently.</p>"},{"location":"api/midi/#linuxpy.midi.device.Sequencer.raw_read","title":"<code>raw_read(max_nb_packets=64) -&gt; Sequence[Event]</code>","text":"<p>Read list of pending events. If there are no events it blocks until at least one event occurs and returns it.</p> <p>Use the <code>read()</code> call instead because it handles blocking vs non-blocking variants transperently.</p>"},{"location":"api/midi/#linuxpy.midi.device.Sequencer.wait_read","title":"<code>wait_read() -&gt; Sequence[Event]</code>","text":"<p>Read list of pending events. If there are no events it blocks until at least one event occurs and returns it. This method assumes the internal file descriptior was opened in non-blocking mode.</p> <p>Use the <code>read()</code> call instead because it handles blocking vs non-blocking variants transperently</p>"},{"location":"api/midi/#linuxpy.midi.device.Sequencer.read","title":"<code>read() -&gt; Sequence[Event]</code>","text":"<p>Read list of pending events. If there are no events it blocks until at least one event occurs and returns it</p>"},{"location":"api/midi/#linuxpy.midi.device.Sequencer.write","title":"<code>write(event: Event)</code>","text":"<p>Send an event message</p>"},{"location":"api/midi/#linuxpy.midi.device.Sequencer.send","title":"<code>send(port: PortAddress, event_type: Union[str, int, EventType], queue: int = QUEUE_DIRECT, to: Union[FullPortAddress, FullPortAddresses] = SUBSCRIBERS, **kwargs)</code>","text":"<p>Send a message of the given type from a specific port to the destination address(es). Use kwargs to pass specific event arguments like velocity in a \"note on\" event.</p> <p>event_type can be an instance of EventType or the equivalent number or a case insensitive string matching the event type (ex: \"noteon\", \"NOTEON\", \"note-on\" or \"note on\").</p> <p>The following example sends \"note on\" with velocity 45 on port 0 of client 14:</p> <pre><code>midi.send((14, 0), \"note on\", velocity=45)\n</code></pre>"},{"location":"api/midi/#linuxpy.midi.device.Client","title":"<code>Client(sequencer: Sequencer, client: snd_seq_client_info)</code>","text":"<p>MIDI sequencer client. Don't instantiate this object directly Use instead <code>Sequencer.get_client()</code></p>"},{"location":"api/midi/#linuxpy.midi.device.Client.name","title":"<code>name: str</code>  <code>property</code>","text":"<p>Client name</p>"},{"location":"api/midi/#linuxpy.midi.device.Client.is_local","title":"<code>is_local: bool</code>  <code>property</code>","text":"<p>True if the client was created by the MIDI sequencer that it references or False otherwise\"</p>"},{"location":"api/midi/#linuxpy.midi.device.Client.iter_ports","title":"<code>iter_ports: Iterable[Port]</code>  <code>property</code>","text":"<p>An iterator over all open ports for this client. It returns new Port each time</p>"},{"location":"api/midi/#linuxpy.midi.device.Client.ports","title":"<code>ports: Sequence[Port]</code>  <code>property</code>","text":"<p>Returns a new list of all open ports for this client</p>"},{"location":"api/midi/#linuxpy.midi.device.Client.__int__","title":"<code>__int__()</code>","text":"<p>The client ID</p>"},{"location":"api/midi/#linuxpy.midi.device.Port","title":"<code>Port(sequencer: Sequencer, port: snd_seq_port_info)</code>","text":"<p>MIDI sequencer port. Don't instantiate this object directly Use instead <code>Sequencer.get_port()</code></p>"},{"location":"api/midi/#linuxpy.midi.device.Port.name","title":"<code>name: str</code>  <code>property</code>","text":"<p>Port name</p>"},{"location":"api/midi/#linuxpy.midi.device.Port.is_local","title":"<code>is_local: bool</code>  <code>property</code>","text":"<p>True if the port was created by the MIDI sequencer that it references or False otherwise\"</p>"},{"location":"api/midi/#linuxpy.midi.device.Port.client_id","title":"<code>client_id: int</code>  <code>property</code>","text":"<p>The client ID</p>"},{"location":"api/midi/#linuxpy.midi.device.Port.port_id","title":"<code>port_id: int</code>  <code>property</code>","text":"<p>The port ID</p>"},{"location":"api/midi/#linuxpy.midi.device.Port.type","title":"<code>type: PortType</code>  <code>property</code>","text":"<p>The port type</p>"},{"location":"api/midi/#linuxpy.midi.device.Port.capability","title":"<code>capability: PortCapability</code>  <code>property</code>","text":"<p>The port capabilities</p>"},{"location":"api/midi/#linuxpy.midi.device.Port.address","title":"<code>address: snd_seq_addr</code>  <code>property</code>","text":"<p>The port address</p>"},{"location":"api/midi/#linuxpy.midi.device.Port.__int__","title":"<code>__int__()</code>","text":"<p>The port ID</p>"},{"location":"api/midi/#linuxpy.midi.device.Port.connect_from","title":"<code>connect_from(src: FullPortAddress)</code>","text":"<p>Connect this port to a remote port. After connecting, this port will receive events originating from the source port.</p> <p>Example:</p> <pre><code>from linuxpy.midi.device import Sequencer\n\nwith Sequencer() as midi:\n    port = midi.create_port()\n    port.connect_from((0, 1))\n    for event in midi:\n        print(event)\n</code></pre>"},{"location":"api/midi/#linuxpy.midi.device.Port.disconnect_from","title":"<code>disconnect_from(src: FullPortAddress)</code>","text":"<p>Disconnect this port from a previously connected source port.</p>"},{"location":"api/midi/#linuxpy.midi.device.Port.connect_to","title":"<code>connect_to(dest: FullPortAddress)</code>","text":"<p>Connect this port to a remote port. After connecting, events originating from this port will be sent to the destination port.</p> <p>Example:</p> <pre><code>from linuxpy.midi.device import Sequencer\n\nwith Sequencer() as midi:\n    port = midi.create_port()\n    # Assume 14:0 is Midi Through\n    port.connect_to((14, 0))\n    port.send(\"note on\", note=11, velocity=10)\n</code></pre>"},{"location":"api/midi/#linuxpy.midi.device.Port.disconnect_to","title":"<code>disconnect_to(dest: FullPortAddress)</code>","text":"<p>Disconnect this port from a previously connected destination port.</p>"},{"location":"api/midi/#linuxpy.midi.device.Port.delete","title":"<code>delete()</code>","text":"<p>Delete this port. Raises MidiError if port is not local. Any subscriptions are canceled before the port is deleted.</p>"},{"location":"api/midi/#linuxpy.midi.device.Port.send","title":"<code>send(event_type: Union[str, int, EventType], **kwargs)</code>","text":"<p>Send a message of the given type from to the destination address(es). Use kwargs to pass specific event arguments like velocity in a \"note on\" event.</p> <p>event_type can be an instance of EventType or the equivalent number or a case insensitive string matching the event type (ex: \"noteon\", \"NOTEON\", \"note-on\" or \"note on\").</p> <p>The following example sends \"note on\" on note 42, with velocity 45:</p> <pre><code>port.send(\"note on\", note=42, velocity=45)\n</code></pre>"},{"location":"api/midi/#linuxpy.midi.device.Event","title":"<code>Event(event: snd_seq_event)</code>","text":"<p>Event message object result of listening on a sequencer</p>"},{"location":"api/midi/#linuxpy.midi.device.Event.__bytes__","title":"<code>__bytes__()</code>","text":"<p>Serialize the Event in a bytes ready to be sent</p>"},{"location":"api/midi/#linuxpy.midi.device.Event.new","title":"<code>new(etype: EventT, **kwargs)</code>  <code>classmethod</code>","text":"<p>Create new Event of the given type</p>"},{"location":"api/midi/#linuxpy.midi.device.to_address","title":"<code>to_address(addr: FullPortAddress) -&gt; snd_seq_addr</code>","text":"<p>Convert to low level snd_seq_addr</p>"},{"location":"api/midi/#linuxpy.midi.device.event_stream","title":"<code>event_stream(sequencer: Sequencer) -&gt; Iterable[Event]</code>","text":"<p>Infinite stream of events coming from the given sequencer</p>"},{"location":"api/midi/#linuxpy.midi.device.async_event_stream","title":"<code>async_event_stream(sequencer: Sequencer, maxsize: int = 10) -&gt; AsyncIterable[Event]</code>  <code>async</code>","text":"<p>Infinite async stream of events coming from the given sequencer</p>"},{"location":"api/video/","title":"Video","text":""},{"location":"api/video/#video-api-reference","title":"Video API reference","text":""},{"location":"api/video/#linuxpy.video.device","title":"<code>linuxpy.video.device</code>","text":"<p>Human API to V4L2 (Video 4 Linux 2).</p>"},{"location":"api/video/#linuxpy.video.device.V4L2Error","title":"<code>V4L2Error</code>","text":"<p>             Bases: <code>Exception</code></p> <p>Video for linux 2 error</p>"},{"location":"api/video/#linuxpy.video.device.Frame","title":"<code>Frame(data: bytes, buff: raw.v4l2_buffer, format: Format)</code>","text":"<p>The resulting object from an acquisition.</p>"},{"location":"api/video/#linuxpy.video.device.EventReader","title":"<code>EventReader(device: Device, max_queue_size=100)</code>","text":""},{"location":"api/video/#linuxpy.video.device.EventReader.aread","title":"<code>aread()</code>  <code>async</code>","text":"<p>Wait for next event or return last event in queue</p>"},{"location":"api/video/#linuxpy.video.device.FrameReader","title":"<code>FrameReader(device: Device, raw_read: Callable[[], Buffer], max_queue_size: int = 1)</code>","text":""},{"location":"api/video/#linuxpy.video.device.FrameReader.aread","title":"<code>aread() -&gt; Frame</code>  <code>async</code>","text":"<p>Wait for next frame or return last frame</p>"},{"location":"api/video/#linuxpy.video.device.create_buffer","title":"<code>create_buffer(fd, buffer_type: BufferType, memory: Memory) -&gt; raw.v4l2_buffer</code>","text":"<p>request + query buffers</p>"},{"location":"api/video/#linuxpy.video.device.create_buffers","title":"<code>create_buffers(fd, buffer_type: BufferType, memory: Memory, count: int) -&gt; list[raw.v4l2_buffer]</code>","text":"<p>request + query buffers</p>"},{"location":"api/video/#linuxpy.video.device.create_mmap_buffers","title":"<code>create_mmap_buffers(fd, buffer_type: BufferType, memory: Memory, count: int) -&gt; list[mmap.mmap]</code>","text":"<p>create buffers + mmap_from_buffer</p>"},{"location":"api/video/#linuxpy.video.device.iter_video_output_files","title":"<code>iter_video_output_files(path: PathLike = '/dev') -&gt; Iterable[Path]</code>","text":"<p>Some drivers (ex: v4l2loopback) don't report being output capable so that apps like zoom recognize them as valid capture devices so some results might be missing</p>"},{"location":"user_guide/","title":"User guide","text":"<p>This tutorial shows you how to use LinuxPy with most of its features.</p>"},{"location":"user_guide/input/","title":"Input","text":"<p>API not documented yet. Just this example:</p> <pre><code>import time\nfrom linuxpy.input.device import find_gamepads\n\npad = next(find_gamepads())\nabs = pad.absolute\n\nwith pad:\n    while True:\n        print(f\"X:{abs.x:&gt;3} | Y:{abs.y:&gt;3} | RX:{abs.rx:&gt;3} | RY:{abs.ry:&gt;3}\", end=\"\\r\", flush=True)\n        time.sleep(0.1)\n</code></pre>"},{"location":"user_guide/input/#asyncio","title":"asyncio","text":"python -m asynciofrom linuxpy.input.device import find_gamepadswith next(find_gamepads()) as pad:    async for event in pad:        print(event)InputEvent(time=1697520475.348099, type=&lt;EventType.SYN: 0&gt;, code=&lt;Synchronization.REPORT: 0&gt;, value=0)InputEvent(time=1697520475.361564, type=&lt;EventType.REL: 2&gt;, code=&lt;Relative.X: 0&gt;, value=-1)InputEvent(time=1697520475.361564, type=&lt;EventType.REL: 2&gt;, code=&lt;Relative.Y: 1&gt;, value=1)InputEvent(time=1697520475.361564, type=&lt;EventType.SYN: 0&gt;, code=&lt;Synchronization.REPORT: 0&gt;, value=0)InputEvent(time=1697520475.371128, type=&lt;EventType.REL: 2&gt;, code=&lt;Relative.X: 0&gt;, value=-1)InputEvent(time=1697520475.371128, type=&lt;EventType.SYN: 0&gt;, code=&lt;Synchronization.REPORT: 0&gt;, value=0)InputEvent(time=1697520475.384468, type=&lt;EventType.REL: 2&gt;, code=&lt;Relative.X: 0&gt;, value=-1)InputEvent(time=1697520475.384468, type=&lt;EventType.REL: 2&gt;, code=&lt;Relative.Y: 1&gt;, value=1)InputEvent(time=1697520475.384468, type=&lt;EventType.SYN: 0&gt;, code=&lt;Synchronization.REPORT: 0&gt;, value=0)InputEvent(time=1697520475.398041, type=&lt;EventType.REL: 2&gt;, code=&lt;Relative.X: 0&gt;, value=-2)InputEvent(time=1697520475.398041, type=&lt;EventType.REL: 2&gt;, code=&lt;Relative.Y: 1&gt;, value=1)InputEvent(time=1697520475.398041, type=&lt;EventType.SYN: 0&gt;, code=&lt;Synchronization.REPORT: 0&gt;, value=0)InputEvent(time=1697520475.424895, type=&lt;EventType.REL: 2&gt;, code=&lt;Relative.X: 0&gt;, value=-1)InputEvent(time=1697520475.424895, type=&lt;EventType.SYN: 0&gt;, code=&lt;Synchronization.REPORT: 0&gt;, value=0)..."},{"location":"user_guide/input/#references","title":"References","text":"<ul> <li>Input (Latest)</li> <li>Input 6.2</li> </ul>"},{"location":"user_guide/midi/","title":"MIDI Sequencer","text":"<p>Without further ado:</p> pythonfrom linuxpy.midi.device import Sequencerwith Sequencer() as seq:    port = seq.create_port()    port.connect_from(14, 0)    for event in seq:        print(event) 14:0   Note on              channel=0, note=100, velocity=3, off_velocity=0, duration=0 14:0   Clock                queue=0, pad=b'' 14:0   System exclusive     F0 61 62 63 F7 14:0   Note off             channel=0, note=55, velocity=3, off_velocity=0, duration=0"},{"location":"user_guide/midi/#system-information","title":"System information","text":"<pre><code>$ python\n&gt;&gt;&gt; from linuxpy.midi.device import Sequencer\n&gt;&gt;&gt; seq = Sequencer(\"a midi client\")\n&gt;&gt;&gt; seq.open()\n\n&gt;&gt;&gt; seq.version\n1.0.2\n\n&gt;&gt;&gt; seq.client_info\nsnd_seq_client_info(client=128, type=1, name=b'a midi client', filter=0, multicast_filter=b'', event_filter=b'', num_ports=0, event_lost=0, card=-1, pid=1288570)\n\n&gt;&gt;&gt; seq.running_mode\nsnd_seq_running_info(client=0, big_endian=0, cpu_mode=0, pad=0)\n\n&gt;&gt;&gt; seq.system_info\nsnd_seq_system_info(queues=32, clients=192, ports=254, channels=256, cur_clients=3, cur_queues=0)\n</code></pre>"},{"location":"user_guide/midi/#asyncio","title":"asyncio","text":"<p>asyncio is a first class citizen to linuxpy.midi:</p> <pre><code>$ python -m asyncio\n\n&gt;&gt;&gt; from linuxpy.midi.device import Sequencer\n&gt;&gt;&gt; with Sequencer() as seq:\n...     port = seq.create_port()\n...     port.connect_from(14, 0)\n...     async for event in seq:\n...         print(event)\n 14:0   Note on              channel=0, note=100, velocity=3, off_velocity=0, duration=0\n 14:0   Clock                queue=0, pad=b''\n 14:0   System exclusive     F0 61 62 63 F7\n 14:0   Note off             channel=0, note=55, velocity=3, off_velocity=0, duration=0\n</code></pre>"},{"location":"user_guide/midi/#cli","title":"CLI","text":"<p>A basic CLI is provided that allows listing MIDI clients &amp; ports and dumping MIDI sequencer events:</p> <p>List all ports:</p> python -m linuxpy.midi.cli ls Port   Client                   Port                     Type                           Capabilities  0:0   System                   Timer                    0                              SR, W, R  0:1   System                   Announce                 0                              SR, R 14:0   Midi Through             Midi Through Port-0      PORT, SOFTWARE, MIDI_GENERIC   SW, SR, W, R <p>Listen to events on selected port(s):</p> python -m linuxpy.midi.cli listen 0:1 14:0  0:1   Port subscribed      sender=(client=0, port=1), dest=(client=128, port=0)  0:1   Port start           client=128, port=1  0:1   Port subscribed      sender=(client=14, port=0), dest=(client=128, port=1)  0:1   Client start         client=130, port=0  0:1   Port start           client=130, port=0  0:1   Port subscribed      sender=(client=130, port=0), dest=(client=14, port=0) 14:0   Note on              channel=0, note=100, velocity=3, off_velocity=0, duration=0  0:1   Port unsubscribed    sender=(client=130, port=0), dest=(client=14, port=0)  0:1   Port exit            client=130, port=0  0:1   Client exit          client=130, port=0  0:1   Port exit            client=129, port=0  0:1   Client exit          client=129, port=0  0:1   Client start         client=129, port=0  0:1   Port start           client=129, port=0 14:0   Note on              channel=0, note=100, velocity=3, off_velocity=0, duration=0 14:0   Note on              channel=0, note=0, velocity=255, off_velocity=0, duration=0 14:0   Note on              channel=0, note=0, velocity=255, off_velocity=0, duration=0"},{"location":"user_guide/video/","title":"Video","text":"<p>Video for Linux 2 (V4L2).</p> <p>Without further ado:</p> from linuxpy.video.device import Devicewith Device.from_id(0) as cam:    for i, frame in enumerate(cam):        print(f\"frame #{i}: {len(frame)} bytes\")        if i &gt; 9:            break...frame #0: 54630 bytesframe #1: 50184 bytesframe #2: 44054 bytesframe #3: 42822 bytesframe #4: 42116 bytesframe #5: 41868 bytesframe #6: 41322 bytesframe #7: 40896 bytesframe #8: 40844 bytesframe #9: 40714 bytesframe #10: 40662 bytes"},{"location":"user_guide/video/#device-creation","title":"Device creation","text":"<p>Create a device object from an ID:</p> <pre><code>from linuxpy.video.device import Device\ncamera = Device.from_id(10)\n</code></pre> <p>from a filename: <pre><code>from linuxpy.video.device import Device\ncamera = Device(\"/dev/video10\")\n</code></pre></p> <p>or from an existing file object:</p> <pre><code>from linuxpy.video.device import Device\nwith open(\"/dev/video10\", \"rb+\", buffering=0) as fd:\n    camera = Device(fd)\n</code></pre> <p>Before using video <code>Device</code> object you need to open it. You can either use the device object as a context manager (prefered):</p> <pre><code>with Device.from_id(10) as camera:\n    ...\n</code></pre> <p>... or manage call <code>Device.open()</code>/<code>Device.close()</code> manually:</p> <pre><code>camera = Device.from_id(10)\ncamera.open()\ntry:\n    ...\nfinally:\n    camera.close()\n</code></pre>"},{"location":"user_guide/video/#capture","title":"Capture","text":"<p>Simple capture without any configuration is possible using the Device object as an infinite iterator:</p> <pre><code>from linuxpy.video.device import Device, VideoCapture\n\nwith Device.from_id(0) as camera:\n    for frame in camera:\n        ...\n</code></pre> <p>The resulting <code>Frame</code> objects can safely and efficiently be converted to bytes.</p> <p>To be able to configure the acquisition, you will need to use the <code>VideoCapture</code> helper. Here is an example with image size and format configuration:</p> <pre><code>from linuxpy.video.device import Device, VideoCapture\n\nwith Device.from_id(0) as camera:\n    capture = VideoCapture(camera)\n    capture.set_format(640, 480, \"MJPG\")\n    with capture:\n        for frame in capture:\n            ...\n</code></pre> <p>Note that <code>VideoCapture</code> configuration must be done before the capture is started (ie, the the <code>with capture:</code> statement.)</p> <p>By default, VideoCapture will use memory map if the device has STREAMING capability and falls back to standard read if not. It is also possible to force a specific reader:</p> <pre><code>from linuxpy.video.device import Capability, Device, VideoCapture\n\nwith Device.from_id(0) as cam:\n    with VideoCapture(cam, source=Capability.READWRITE):\n        for frame in capture:\n            ...\n</code></pre>"},{"location":"user_guide/video/#information","title":"Information","text":"<p>Getting information about the device:</p> <pre><code>&gt;&gt;&gt; from linuxpy.video.device import Device, BufferType\n\n&gt;&gt;&gt; cam = Device.from_id(0)\n&gt;&gt;&gt; cam.open()\n&gt;&gt;&gt; cam.info.card\n'Integrated_Webcam_HD: Integrate'\n\n&gt;&gt;&gt; cam.info.capabilities\n&lt;Capability.STREAMING|EXT_PIX_FORMAT|VIDEO_CAPTURE: 69206017&gt;\n\n&gt;&gt;&gt; cam.info.formats\n[ImageFormat(type=&lt;BufferType.VIDEO_CAPTURE: 1&gt;, description=b'Motion-JPEG',\n             flags=&lt;ImageFormatFlag.COMPRESSED: 1&gt;, pixelformat=&lt;PixelFormat.MJPEG: 1196444237&gt;),\n ImageFormat(type=&lt;BufferType.VIDEO_CAPTURE: 1&gt;, description=b'YUYV 4:2:2',\n             flags=&lt;ImageFormatFlag.0: 0&gt;, pixelformat=&lt;PixelFormat.YUYV: 1448695129&gt;)]\n\n&gt;&gt;&gt; cam.get_format(BufferType.VIDEO_CAPTURE)\nFormat(width=640, height=480, pixelformat=&lt;PixelFormat.MJPEG: 1196444237&gt;}\n\n&gt;&gt;&gt; for ctrl in cam.controls.values(): print(ctrl)\n&lt;IntegerControl brightness min=0 max=255 step=1 default=128 value=128&gt;\n&lt;IntegerControl contrast min=0 max=255 step=1 default=32 value=32&gt;\n&lt;IntegerControl saturation min=0 max=100 step=1 default=64 value=64&gt;\n&lt;IntegerControl hue min=-180 max=180 step=1 default=0 value=0&gt;\n&lt;BooleanControl white_balance_automatic default=True value=True&gt;\n&lt;IntegerControl gamma min=90 max=150 step=1 default=120 value=120&gt;\n&lt;MenuControl power_line_frequency default=1 value=1&gt;\n&lt;IntegerControl white_balance_temperature min=2800 max=6500 step=1 default=4000 value=4000 flags=inactive&gt;\n&lt;IntegerControl sharpness min=0 max=7 step=1 default=2 value=2&gt;\n&lt;IntegerControl backlight_compensation min=0 max=2 step=1 default=1 value=1&gt;\n&lt;MenuControl auto_exposure default=3 value=3&gt;\n&lt;IntegerControl exposure_time_absolute min=4 max=1250 step=1 default=156 value=156 flags=inactive&gt;\n&lt;BooleanControl exposure_dynamic_framerate default=False value=False&gt;\n\n&gt;&gt;&gt; cam.controls[\"saturation\"]\n&lt;IntegerControl saturation min=0 max=100 step=1 default=64 value=64&gt;\n\n&gt;&gt;&gt; cam.controls[\"saturation\"].id\n9963778\n&gt;&gt;&gt; cam.controls[9963778]\n&lt;IntegerControl saturation min=0 max=100 step=1 default=64 value=64&gt;\n\n&gt;&gt;&gt; cam.controls.brightness\n&lt;IntegerControl brightness min=0 max=255 step=1 default=128 value=128&gt;\n&gt;&gt;&gt; cam.controls.brightness.value = 64\n&gt;&gt;&gt; cam.controls.brightness\n&lt;IntegerControl brightness min=0 max=255 step=1 default=128 value=64&gt;\n</code></pre> <p>(see also v4l2py-ctl example)</p>"},{"location":"user_guide/video/#asyncio","title":"asyncio","text":"<p>linuxpy.video is asyncio friendly:</p> python -m asynciofrom linuxpy.video.device import Devicewith Device.from_id(0) as camera:    async for frame in camera:        print(f\"frame {len(frame)}\")frame 10224frame 10304frame 10224frame 10136... <p>(check basic async and web async examples)</p>"},{"location":"user_guide/video/#gevent","title":"gevent","text":"<p>linuxpy.video is also gevent friendly:</p> <pre><code>$ python\n\n&gt;&gt;&gt; from linuxpy.io import GeventIO\n&gt;&gt;&gt; from linuxpy.video.device import Device\n&gt;&gt;&gt; with Device.from_id(0, io=GeventIO) as camera:\n...     for frame in camera:\n...         print(f\"frame {len(frame)}\")\nframe 10224\nframe 10304\nframe 10224\nframe 10136\n...\n</code></pre> <p>(check basic gevent and web gevent examples)</p>"},{"location":"user_guide/video/#video-output","title":"Video output","text":"<p>It is possible to write to a video output capable device (ex: v4l2loopback). The following example shows how to grab frames from device 0 and write them to device 10:</p> <pre><code>&gt;&gt;&gt; from linuxpy.video.device import Device, VideoOutput, BufferType\n&gt;&gt;&gt; dev_source = Device.from_id(0)\n&gt;&gt;&gt; dev_sink = Device.from_id(10)\n&gt;&gt;&gt; with dev_source, dev_target:\n&gt;&gt;&gt;     source = VideoCapture(dev_source)\n&gt;&gt;&gt;     sink = VideoOutput(dev_sink)\n&gt;&gt;&gt;     source.set_format(640, 480, \"MJPG\")\n&gt;&gt;&gt;     sink.set_format(640, 480, \"MJPG\")\n&gt;&gt;&gt;     with source, sink:\n&gt;&gt;&gt;         for frame in source:\n&gt;&gt;&gt;             sink.write(frame.data)\n</code></pre> <p>By default, VideoOutput will use memory map if the device has STREAMING capability and falls back to standard write if not. It is also possible to force a specific writer with <code>VideoOutput(cam, sink=Capability.READWRITE)</code>:</p>"},{"location":"user_guide/video/#v4l2loopback","title":"v4l2loopback","text":"<p>This is just an example on how to setup v4l2loopback.</p> <p>Start from scratch:</p> <pre><code># Remove kernel module and all devices (no client can be connected at this point)\nsudo modprobe -r v4l2loopback\n\n# Install some devices\nsudo modprobe v4l2loopback video_nr=20,21 card_label=\"Loopback 0\",\"Loopback 1\"\n</code></pre>"},{"location":"user_guide/video/#references","title":"References","text":"<p>See the <code>linux/videodev2.h</code> header file for details.</p> <ul> <li>V4L2 (Latest) (videodev.h)</li> <li>V4L2 6.2 (videodev.h)</li> </ul>"}]}